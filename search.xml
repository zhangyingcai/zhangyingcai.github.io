<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript进阶系列-Event Loop]]></title>
    <url>%2F2019%2F04%2F25%2FJavaScript-super-1%2F</url>
    <content type="text"><![CDATA[前端工程师必须要懂得33个知识点 Event Loop Event loopjavaScript 的并发模型基于“事件循环”。 在了解执行栈之前先来了解一些概念 运行时概念( runtime concepts)如图 栈(stack)先进后出 堆(heap)对象被分配在一个堆中，是一个用于表示一大块非结构化的内存区域 队列先进先出 什么事执行栈(调用栈)？执行栈，就是代码执行期间调用函数形成的调用栈。是引擎在追踪函数执行流的一种机制。当执行环境中调用了多个函数时，我们能够追踪到哪个函数正在执行，执行的函数又调用了哪个函数。 todo 什么时间创建栈？个数限制？ 答：javaScript 是一门单线程的语言，这意味着它只有一个调用栈。 单个栈的数量是有限制的12345function func() &#123; func()&#125;func()//Maximum call stack size exceeded 调用栈[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 当脚本要执行一个函数时，引擎把该函数添加到栈中并执行 任何被这个函数调用的函数会进一步添加到调用栈中，并且会运行到他们被上个程序调用的位置 当函数运行结束后，引擎将他从调用栈中取出，并在主代码列表中继续执行代码 如果栈调用的空间比分配给它的内存空间大，则会导致”栈溢出” Event Loop 中异步代码的执行顺序？ Event Loop 是什么？上面说到什么是执行栈，也就是说 javaScript 引擎在执行代码的时候，遇到函数会将函数压入执行栈，函数执行完弹出栈。 但是遇到异步代码怎么办？ 异步代码会被挂起，并在需要执行的时候放到队列中，宏任务放到宏任务队列队尾，微任务放到微任务队列队尾，当当前执行栈为空时，从队列中获取需要执行的代码并执行。本质上异步还是同步。 异步函数被分为 宏任务 和 微任务 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。 Event Loop 的执行顺序 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） 事件循环模型的特性，永不阻塞 总结：JavaScript异步、事件循环与消息队列、微任务与宏任务]]></content>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个知识点之Object]]></title>
    <url>%2F2019%2F04%2F24%2FjavaScript-Object%2F</url>
    <content type="text"><![CDATA[每天一个知识点之Object]]></content>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2019%2F04%2F24%2Fsvg%2F</url>
    <content type="text"><![CDATA[怎么通过 svg 实现 wifi 图标根据信号动态展示还有动画效果呢？ 推荐参考未来必热：SVG Sprite技术介绍]]></content>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题目]]></title>
    <url>%2F2019%2F04%2F23%2Fleetcode%2F</url>
    <content type="text"><![CDATA[给定两个数组，写一个方法来计算它们的交集。 给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。12let intersection = (...arg) =&gt; arg[0].filter(v =&gt; arg[1].includes(v));// 但是[1,2,2,1] [2] 返回 [2,2] 这道题两种思路，空间换时间，或者不用额外空间就提升时间复杂度。 空间换时间的思路是用个Hash表来存数组1的元素以及出现的个数（此处需要遍历n次，并存一个n级别的空间）。遍历数组2，发现数组2里有Hash表里的值就存到Result数组里，并把Hash表内该值次数减一（为0之后就Delete）。如果不存在Hash表里，就跳过。这样时间复杂度就是(m+n) 不用额外空间，就用遍历n的时候，判断值在不在m里，如果在，把m里的该值push到Result数组里，并将该值从m数组里删掉（用splice）。这样就是不用额外空间，但是提高了时间复杂度。 最终实现时间123456789101112131415161718const intersect = (nums1, nums2) =&gt; &#123; const map = &#123;&#125; const res = [] for (let n of nums1) &#123; if (map[n]) &#123; map[n]++ &#125; else &#123; map[n] = 1 &#125; &#125; for (let n of nums2) &#123; if (map[n] &gt; 0) &#123; res.push(n) map[n]-- &#125; &#125; return res&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F19%2Fwinter%2Fwinter36%2F</url>
    <content type="text"><![CDATA[Document document.body.addEventListener('mousedown', function(e){ console.log('body'); }, true); // 捕获 document.getElementById('input').addEventListener('mousedown', function(){ console.log('input'); }, true) document.body.addEventListener('mousedown', function(){ console.log('body1'); }, false); // 冒泡 document.getElementById('input').addEventListener('mousedown', function(){ console.log('input1'); }, false)]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫]]></title>
    <url>%2F2019%2F04%2F15%2Freptile%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[重学前端]]></title>
    <url>%2F2019%2F04%2F04%2Fwinter%2F</url>
    <content type="text"><![CDATA[重学前端笔记 38 css的动画和交互CSS动画相关的属性有两个：animation 属性和 transition 属性 animation 分为6个部分 animation-name: 动画的名称，这是一个 keyframes 类型的值 （第九节，keyframes 产生一种数据，用于定义动画关键帧） animation-duration：动画的时长 animation-timing-function 动画的时间曲线 animation-delay 动画开始前的延时 animation-iteration-count 动画的播放次数 animation-direction 动画的方向 animation-name 用来表示动画的名称，需要配合@规则来使用 1234567@keyframes myanimation&#123; 0%&#123; top: 0 &#125; 25%&#123; top: 10px &#125; 50%&#123; top: 30px &#125; 75%&#123; top: 70px &#125; 100%&#123; top: 150px &#125;&#125; transition transition-property 属性 transition-duration 时间 transition-timing-function 时间曲线 transition-delay 延时 36 浏览器事件1234567891011121314151617&lt;body&gt; &lt;input id=&apos;input&apos;/&gt;&lt;/body&gt;&lt;script&gt;document.body.addEventListener(&apos;mousedown&apos;, function(e)&#123; console.log(&apos;body&apos;);&#125;, true); // 捕获document.getElementById(&apos;input&apos;).addEventListener(&apos;mousedown&apos;, function()&#123; console.log(&apos;input&apos;);&#125;, true)document.body.addEventListener(&apos;mousedown&apos;, function()&#123; console.log(&apos;body1&apos;);&#125;, false); // 冒泡document.getElementById(&apos;input&apos;).addEventListener(&apos;mousedown&apos;, function()&#123; console.log(&apos;input1&apos;);&#125;, false)&lt;/script&gt; 最终的顺序是1234bodyinputinput1body1 在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。 1234target.addEventListener(type, listener[, options]);// option: capture...target.addEventListener(type, listener[, useCapture]);// useCapture 默认为false 默认使用冒泡机制，遇到父元素控制子元素的行为时，可以使用捕获机制。 常用的三个参数： 事件名称 事件处理函数 捕获还是冒泡（useCapture） 事件的处理函数不一定是函数，也可以是个javaScript具有handleEvent方法的对象12var o = &#123; handleEvent:event =&gt; console.log()&#125;document.body.addEventListener(&apos;click&apos;, o, false); 焦点键盘事件是由焦点系统控制的，一般来说，操作系统也会提供一套焦点系统，但是现代浏览器一般都选择在自己的系统内覆盖原本的焦点系统。 浏览器api来操作焦点12document.body.focusdocument.body.blur 自定义事件只能在 DOM 元素上使用自定义事件。自定义事件的代码示例如下（来自 MDN）12var evt = new Event(&quot;look&quot;, &#123;&quot;bubbles&quot;:true, &quot;cancelable&quot;:false&#125;);document.dispatchEvent(evt); 这里使用 Event 构造器来创造了一个新的事件，然后调用 dispatchEvent 来在特定元素上触发。 注意，这里旧的自定义事件方法（使用 document.createEvent 和 initEvent）已经被废弃。 31 什么是表达式语句？ 事实上真正能干活的语句并不多，其他语句的作用就是产生各种结构，来控制表达式语句执行，或者改变表达式语句的意义。 什么是表达式语句？表达式语句其实是一个表达式，是由运算符链接变量或者直接量构成的 123变量？直接量？直接量就是用语法写出来的具有特定类型的值 表达式语句 函数调用赋值自增/自减 语法上，并没有限制，可以有无意义的表达式1a+b; 有哪些表达式?主要表达式：primary Expression.它是表达式的最小单位，它所涉及的语法结构的优先级也是最高的。 primary Expression 还可以是this或者变量，在语法上，把变量称作”标识符引用” 12this;myVar; 在任何表达式加上圆括号，都被认为是 Primary Expression， 这个机制使得圆括号成为改变运算符优先顺序的手段。 Member Expression 成员表达式由主要表达式构成的成员表达式 主要用于访问对象成员.语法 // 属性访问[‘myVar’] // 字符串的属性访问new.target // 用于判断对象是否被new调用super.b // 用于访问父类的属性的语法 1f`a$&#123;b&#125;c` //这是一个是带函数的模板，这个带函数名的模板表示把模板的各个部分算好后传递给一个函数。 浏览器工作机制]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2019%2F03%2F27%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex 记录 vuex 是什么？vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 全局单例管理组件共享的状态。 state单一状态树 用一个对象就包含了全部的应用层级状态。 每一个应该将仅仅包含一个store实例。 在 vue 组件中获取 Vuex 状态vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态 通过根实例注册 store 选项，该store实例会注入到跟组件下的所有子组件中，且子组件能通过 this.$store 访问到。 mapState 辅助函数当一个组件获取多个状态时候，将这些状态都声明为计算属性]]></content>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F22%2Fcss%2Fclearboth%2F</url>
    <content type="text"><![CDATA[清除浮动]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F19%2Fdebounce%2F</url>
    <content type="text"><![CDATA[Document 正常 点我防抖 点我立即执行 点我立即执行防抖 节流 简易节流 vue 防抖应用 Ask a yes/no question: var watchExampleVM = new Vue({ el: '#watch-example', data: { question: '', answer: 'I cannot give you an answer until you ask a question!' }, watch: { // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() } }, created: function () { // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) }, methods: { getAnswer: function () { if (this.question.indexOf('?') === -1) { this.answer = 'Questions usually contain a question mark. ;-)' return } this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) { vm.answer = _.capitalize(response.data.answer) }) .catch(function (error) { vm.answer = 'Error! Could not reach the API. ' + error }) } } }) const debounce = (func, wait = 500) => { let timer = null return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() => { func.apply(this, args) }, wait) } } const debounce1 = (func, wait = 50, immediate = true) => { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } // 获取时间戳(毫秒数) function now() { return +new Date() } const throttle = (func, wait, options)=>{ var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; } // 简易版 const throttle1 = (func, wait)=>{ let timer = null let leading = false return function(...args){ if(leading) return leading = true setTimeout(() => { func.apply(this, args), leading = false}, wait) } } document.getElementById("button").addEventListener("click", debounce(() => { console.log("防抖成功") })); document.getElementById("button1").addEventListener("click", debounce(() => { console.log("立即执行成功！") })); document.getElementById("button2").addEventListener("click", debounce(() => { console.log("立即防抖成功！") },1000, false)); function down(){ console.log(1); } document.getElementById("button3").addEventListener("click", throttle(() => { console.log("节流成功！") },1000)); document.getElementById("button4").addEventListener("click", throttle1(() => { console.log("简易节流成功！") },1000));]]></content>
  </entry>
  <entry>
    <title><![CDATA[datetime]]></title>
    <url>%2F2019%2F03%2F13%2Fdatetime%2F</url>
    <content type="text"><![CDATA[遇到 +new Date() 没有明白，特来学习一下在这里+相当于函数.valueOf 等同于 (new Date()).valueOf返回当前时间的毫秒数 toDo: valueOf的用法和js获取时间的用法]]></content>
      <categories>
        <category>datetime</category>
      </categories>
      <tags>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web总结]]></title>
    <url>%2F2019%2F03%2F07%2Fweb%2F</url>
    <content type="text"><![CDATA[面试题总结 CSScss实现图片自适应宽高？自适应宽和高 // 根据当前父级元素的大小自动更新大小1234img&#123; max-width:100%; min-height:100%;&#125; 等比例缩放图片的话1234img&#123; width:100%; height:auto;&#125; Ajax目的：网页能够快速将增量更新展示到页面上，而不用刷新页面，能够快速响应用户的操作，提升了用户体验。 交互模型： 同步异步的区别：同步暂停当前脚本等待服务器处理结果，异步的话是继续执行当前脚本，服务器又返回时处理结果 JavaScript异步加载js的方案默认情况javascript是同步加载的，所以通常js文件放到文档底部，优先展示样式。 defer 只支持IE async 使用document创建script,插入到DOM中，加载完毕后callback123456789101112131415function loadScript(url, callback) &#123; var script = document.createElement(&quot;script&quot;); script.type = &quot;text/javascript&quot;; if (script.readyState) &#123; //IE script.onreadystatechange = function () &#123; if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;) &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; //Others: Firefox, Safari, Chrome, and Opera script.onload = function () &#123; callback(); &#125;; &#125; script.src=url; document.body.appendChild(script);&#125; 网站可用性、可访问性面试总结 box-sizing12content-box // 标准盒模型 `width` 与 `height` 只包括内容的宽和高border-box // width = border + padding + 内容的高度 promise用法清除浮动的方法，应用场景以及为什么清除浮动。floatclear:both;overflow:auto; 千分位分割数字，并自定义保留小数位数正则表达式123function money(num)&#123; return (&apos;&apos;+num).replace(/(\d)(?=(\d&#123;3&#125;)+(?!\d))/g, &apos;$1,&apos;);&#125; 首先考虑的是小数点，在小数点的地方进行位置划分//g;//g全局匹配 /(\d)(?=(\d{3})+.)/g;\d:匹配一个数字字符，等价于[0-9]这里最难理解的就是(?=(\d{3})+.)，且看语法：x(?=y)：正向肯定查找，匹配后面带有y的x项目 那么在这里意思是：查找一个和”.”之间带有一个或多个连续3位数字的数字（x）123456789101112131415161718192021/** *num 要分隔的数字（必填） *n 保留的小数位数（可选） *symbol 分隔数字使用的符号（可选，默认为&quot;,&quot;） */ function splitNum(num,n,symbol) &#123; if(!num)throw new Error(&apos;splitNum需要传入一个待转换的数据&apos;); if(typeof num!==&apos;number&apos;)throw new TypeError(&apos;num参数应该是一个number类型&apos;); if(n&lt;0)throw new Error(&apos;参数n不应该小于0&apos;); var hasDot=parseInt(num)!=num;//这里检测num是否为小数，true表示小数 var m=(n!=undefined&amp;&amp;n!=null)?n:1; num=m==0?num.toFixed(m)+&apos;.&apos;:hasDot?(n?num.toFixed(n):num):num.toFixed(m); symbol=symbol||&apos;,&apos;; num=num.toString().replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g,function(match, p1,p2) &#123; return p1 + symbol; &#125;); if(n==0||(!hasDot&amp;&amp;!n))&#123;//如果n为0或者传入的num是整数并且没有指定整数的保留位数，则去掉前面操作中的小数位 num=num.substring(0,num.indexOf(&apos;.&apos;)); &#125; return num;&#125; ##1234567891011function money(num)&#123; // 先把数字换成字符串，然后转换成数组，反转之后，再组合成字符串 var reverseStr = num.toString().split(&apos;&apos;).reverse().join(&apos;&apos;); // 用正则替换，每隔3位加一个逗号 reverseStr = reverseStr.replace(/(\d&#123;3&#125;)/g,&apos;$1,&apos;); // 处理正好三位的情况，如 123 -&gt; ,123 reverseStr = reverseStr.replace(/\,$/,&apos;&apos;); // 把加了逗号的字符串反转回正常的顺序 reverseStr = reverseStr.split(&apos;&apos;).reverse().join(&apos;&apos;); return reverseStr;&#125; (123456.123).toLocaleString(‘en-US’) ie11以上支持mdn参考]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化]]></title>
    <url>%2F2019%2F03%2F07%2Fesmodules%2F</url>
    <content type="text"><![CDATA[归纳 模块化 意义模块化的意义是为了抽离公共代码，把相同、相似的功能放到一个组件，实现一个组件完成一个功能的设计，方便开发和维护，降低开发成本，形成一套高效的工具隔离作用域，避免变量冲突 使用自执行函数来编写模块化（在一个单独的函数作用域中执行） 123()(function()&#123; // code&#125;) AMD：使用requireJS来编写模块化（依赖必须提前声明好） 123define(&apos;./index.js&apos;, function(code)&#123; // code 是index返回的内容&#125;) CMD：使用seaJS(支持动态引入依赖文件) 123define(function(require, exports, module) &#123; var indexCode = require(&apos;./index.js&apos;); // indexCode 是index返回的内容&#125;); CommonJS：node中带的模块化 1var fs = require(&apos;fs&apos;); UMD 兼容AMD、CommonJS模块化语法 ES modules:es6 引入的模块化]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript权威指南第6版]]></title>
    <url>%2F2019%2F03%2F05%2Fjs-quanwei%2F</url>
    <content type="text"><![CDATA[阅读笔记 JavaScript程序是用Unicode字符集编写的 区分大小写(js文件或标签当中是严格执行的，HTML的不是) 数据类型分为原始类型和对象类型，特殊对象： 全局对象、数组、函数 如果函数用来初始化(使用new运算符)一个新建的对象，称之为构造函数 有用的类：日期(Date)、正则(RegExp)、错误(error) JavaScript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收 只有null和undefined是无法拥有方法的值 JavaScript的类型可以分为原始类型和对象类型，也可以分为可以拥有方法的类型和不能拥有方法的类型，同样可以分为可变类型和不可变类型。 类型、值和变量字符串 ES5 字符串通过()换行，反斜线和行结束符都不算字符串的内容，解决字符串当中的单引号和双引号的问题是将其转义 当JavaScript代码和HTML代码混杂在一起的时候，最好是在JavaScript和Html代码中各自使用独立的引号风格，例如在JavaScript中统一使用单引号，HTML中统一使用双引号。 字符串是固定不变的，这些操作都是返回新的字符串 字符串使用 字符串长度 str.length 获取当个字符 str.charAt(index) 0开始计算 截取字符串 str.substring(star, end) 0开始计算 转义字符 \n换行符 \r回车符 \\反斜线 \f换页符 英文当中的撇号 模式匹配布尔值表达式和运算符 通过this调用宿主对象 并不是方法调用的调用表达式通常使用全局对象作为this关键字的值。ES5中通过严格模式定义的函数在调用的时候将使用undefined作为this的值，this不会指向全局对象。 对象创建表达式 new Object()如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么圆括号可以省略new Object 当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，JavaScript首先创建一个新的空对象，然后，JavaScript通过传入指定的参数并将这个新对象当做this来初始化这个新创建对象的属性。那些被当做构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象作为整个对象创建表达式的值，而新创建的对象就废弃了。（所以一般不返回对象） 运算符优先级 属性访问表达式和调用表达式的优先级比运算符要高 相同级别的运算符根据结合性判断执行顺序 JavaScript总是严格按照从左至右的顺序来计算表达式instanceof 如果左运算符不是对象的话返回false]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript权威指南第6版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2019%2F03%2F05%2Fwebpack%2F</url>
    <content type="text"></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读计划]]></title>
    <url>%2F2019%2F03%2F05%2Flearn%2F</url>
    <content type="text"><![CDATA[书单计划 #本职业 JavaScript权威指南第6版 （3月）人月神话 （3月） #商科 经济学原理 曼昆 （3月-4月）]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new操作符]]></title>
    <url>%2F2019%2F03%2F04%2Fjs-new%2F</url>
    <content type="text"><![CDATA[js中的new操作符 new 的作用12345678// 语法new constructor([arguments]) // new + 构造函数（参数）当代码 `new Foo(...)` 执行时，会发生以下事情：一个继承自 `Foo.prototype` 的新对象被创建。使用指定的参数调用构造函数 `Foo` ，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 `new Foo()`，也就是没有指定参数列表，`Foo` 不带任何参数调用的情况。由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 123456function create(Con, ...args)&#123; let obj = &#123;&#125; Object.setPrototypeOf(obj, Con.prototype) let result = Con.apply(obj, args) return result instanceof Object ? result : obj&#125; 参考 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用 然后内部创建一个空对象 obj 因为 obj 对象需要访问到构造函数原型链上的属性，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 * obj.proto = Con.prototype 将 obj 绑定到构造函数上，并且传入剩余的参数 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值 Object.setPrototypeOf1设置一个对象的原型到另一个对象 语法Object.setPrototypeOf(obj, prototype) 参数obj 要设置其原型的对象prototype 该对象的新原型 获取对象的原型可以使用obj.__proto__，设置原型链不建议使用该方法mdn参考]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信分享]]></title>
    <url>%2F2019%2F02%2F27%2Fwx%2F</url>
    <content type="text"><![CDATA[微信分享踩得坑 desc 最好不带中文换行符和单双引号imgurl 最好使用缩略图]]></content>
      <tags>
        <tag>微信分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web-ios]]></title>
    <url>%2F2019%2F02%2F26%2Fweb-ios%2F</url>
    <content type="text"><![CDATA[记录在开发过程中遇到的iOS需要适配的问题 mate 相关注意事项汇总1234567891011121314&lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--主要I是强制让文档的宽度与设备宽度保持1:1，最大宽度1.0，禁止屏幕缩放。--&gt;&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;&lt;!--这个也是iphone私有标签，允许全屏浏览。--&gt;&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;&lt;!--iphone的私有标签，iphone顶端状态条的样式。--&gt;&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;&lt;!--禁止数字自动识别为电话号码，这个比较有用，因为一串数字在iphone上会显示成蓝色，样式加成别的颜色也是不生效的。--&gt;&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;&lt;!--禁止email识别--&gt;&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;&lt;!-- 强制横屏或竖屏 --&gt;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;//uc&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;//qq input输入框自动放大的问题runoob mate name=”viewport” 添加 “user-scalable=no” 禁止手动缩放 shrink-to-fit(自适应宽度)下面的代码可以让网页的宽度自动适应手机屏幕的宽度1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; iOS9以上生效要添加”shrink-to-fit=no”原因如下123Viewport meta tags using&quot;width=device-width&quot; cause the page to scale down to fit content that overflows the viewport bounds.You can override this behavior by adding &quot;shrink-to-fit=no&quot; to your meta tag as shown below.The added value will prevent the page from scaling to fit the viewport. 记录一个由于IOS mobile chrome由transition引发的问题测试出来只有在iOS12.1.14版本 的mobile charome上出现的问题 版本72.0.3626.101 问题是阅读页面吊顶，用户点击当前页面显示隐藏顶部操作栏，在手机上出现闪烁，每次的初始位置在元素下方很远的位置 123456789101112131415.transHead&#123;// 默认上移77px transition: all .2s linear; transform: translateY(-77px); -webkit-transform: translateY(-77px); -ms-transform: translateY(-77px); -moz-transform: translateY(-77px); -o-transform: translateY(-77px);&#125;.moveIn &#123; // 点击后移入页面动画 transform: translateZ(0)!important; -webkit-transform: translateZ(0)!important; -ms-transform: translateZ(0)!important; -o-transform: translateZ(0)!important; -moz-transform: translateZ(0)!important;&#125; 仔细检查transform没有发现问题，偶然发现淘宝大神写的一篇文章这里发现transition会导致这个问题，果断使用排除法测试，真的是这个属性的问题（苦笑）。Google关键字“Chrome transition blink”和“Chrome transition bug”解决方案： -webkit-backface-visibility: hidden;（设置进行转换的元素的背面在面对用户时是否可见：隐藏）perspective:1000;(观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果) -webkit-transform-style: preserve-3d; （设置内嵌的元素在 3D 空间如何呈现：保留 3D ） 亲测上述两种方法都是有效的。不过第二种方法有时候会复现。 webkit 私有属性 -webkit-overflow-scrolling: touch 运行独立的滚动区域和触摸回弹]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ios适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购物车]]></title>
    <url>%2F2019%2F02%2F26%2Fshoppingcart%2F</url>
    <content type="text"><![CDATA[关于电商平台购物车的理解 做电商的一般都有购物车的设计，用于记录用户的购买意愿这时候就会涉及到一个库存的问题，因为上架的实际库存是一定的，但是我们怎么设计，在用户添加购物车到下单到付款的体验更优呢？ 这时会有 下单减库存、付款减库存、放进购物车减库存 下单减库存 就是在用户下单的时候减库存，但是用户还没有付款，这笔交易还没有成功，会和12306的抢票是类似的。这个方案无法规避商品恶意被拍的风险。导致真正需要的消费者无法购买，12306的情况就是这样，然后催生了一批刷票的抢(黄)票(牛)软件。然后经常碰到的就是显示的有票，下单无票的情况，体验很差。 付款减库存 只有在消费者付款之后减库存，这样会导致超卖，超卖的订单会提示库存不足，导致用户体验不好。 放进购物车减库存 就是在消费者将商品放进购物车时就减库存。优点：可以在生成订单之前就确定是否有货。缺点是无法规避商品恶意被拍的风险。 淘宝做法：购物车不会减少库存。下单后锁定库存，但是会在相应的购物车和下单时给予用户提示。有一个预售库存到实际库存的过程。 京东：微店中卖家可以设置“拍下减库存”或者“付款减库存”的，并给出想应的优劣分析。 1.拍下减库存买家拍下商品,库存数量就相应减少,24小时后仍未付款,恢复库存数量。好处：保证买家只要拍下宝贝,就一定能买到坏处：1)在库存紧张时,买家拍下之后不付款,会影响其他买家购买 2)可能有人恶意占用库存,给店家造成损失建议：库存充足的店家使用2.付款减库存买家拍下商品，先预扣库存，如果15分钟内付款则减去库存；如果超过15分钟未付款，则释放库存。好处：库存不会被长时间占用,当库存紧张时,真正想买的客户有更多机会买到宝贝坏处：可能出现超卖,最后一个库存被多个客户同时付款,就需要店家和客户协商解决。一般会通过短信和订单详情页提醒的方式通知店家和客户建议：库存紧张、需要防止被占用的店家使用秒杀、限时折扣等活动商品不生效。]]></content>
      <tags>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软实力]]></title>
    <url>%2F2019%2F02%2F26%2Fruanshili%2F</url>
    <content type="text"><![CDATA[做为一个人的软实力 我自己前期自我努力-》给你的学历和天赋（没有学历补学历，没有人脉积累人脉，提高自己的为人处世）当前家庭所在位置-》（提供自己生长环境、人脉、认知、基础）你的后天认知 个人性格随遇而安（不思进取）不善交际（闷）幻想型双鱼座（骚） 解决方案（ToDo）目标：智商情商结交人脉为人处世有眼光有内涵有修养的大叔那些年你偷过的懒和犯过的事都要加倍弥补 学生思维 自我总结现在还有的学生思维，曾经犯过的问题，写到笔记里。制定一个详细的规划，在今年改掉它。 和父母进行一次聊天。去问问你父母在工作职场里都曾经犯过什么学生思维的错误，他们肯定不愿意说，要多问。记录下来，分析一下原因和解决方案。 了解新基建和5g。理解目前a股市场里的相关概念股票，并了解每一个公司的实际业务。但不要随便投资。理解今年的趋势。 本行业理解当前行业的玩法。理解一专一副。理解白天鹅和黑天鹅。 目标：积累资源人脉发现信息差成为黑天鹅。 当前改革削弱部分不应该去（地方权利降低）公务员的话必须是省或者一、二线城市体制内是和城市绑定在一起的，和城市强绑定的，所以选择城市最重要。所以一定要选择当前有实力的，未来有前景的。 行业发展任何行业到了最后都是拼的存量，就是经营自己的黏性用户，所以最后拼的是运营。而技术和产品相对萎缩。 每一个消费升级对应的都有消费降级。消费升级：行业头部，在这个行业头部的这部分人的需求。消费降级：行业底部或者行业外的需求。 选择当前自己适合的当下或者未来有前景的头部行业的头部公司 玩法工作1年-10年 积累的最佳时机： 刚出校园的1-3年 社会没有一个统一的评判标准当前积累自己的软技能和硬技能智商和情商积累加深对社会的理解这是个拉开距离的关键时期（错过了就要加倍的努力） 人生人生就是一场修行，修成我们想要的样子。(todo:你想要什么？) 软实力第一式-识人人最重要的品质：人品、思维、精神状态。 交朋友选择这三种状态比较优秀的。 认识自我社会的各个模块：政治、经济、实业。个人的模块：家、国家、国外。个人社交模块：家人、亲戚、朋友、同事、领导、认识的人、陌生人。个人事业模块：本行业、本行业上下游、其他行业。社会生活是个综合性的认识。所以这个提升也是在你具有相同综合性的认识提升产生的综合效应。要具有的认知：1.商科思维2.心里框架3.阶级4.社交人脉 重在实践！！！ 人生是一场修行（一）今年过完年我就在想一个问题，我想要的是什么？从毕业之后，我踏入社会，入了社会这所没有标准考试的大学，在这里，一切没有标准。社会是多因子交叉构成的，它不是你大学里面分的清楚的学科，每个学科定理公理写的明明白白，最后评判结果按照分数有正确答案的。进入这个社会首先想到的是生存，当初只是知道我毕业了，长大了，要自己赚钱养活自己，然后就去找一份工作，至于职业规划什么的都不清楚（即使是现在），就是想找一份工作，当时不知道就入了程序员的行业，因为我们学的是电子信息工程，是一个偏硬件和弱电的行业，高不成低不就，不读研仅靠本科的技术积累很难进入好的单位。 随后就是在单位里工作，根据工作需要调整生活和工作的计划，感觉像完成作业一样的活一天。 几年的磨练，和平时的积累以及见识，同时也灌了不少的鸡汤，开始对这个社会有些想法。 想要生存下去，必须学会适应，想要更好的生存，就要有生存的方法。 当然大多数人都想我一样，每天为了工资然后努力工作。但是我想做出一些改变，就开始思考这个社会，但是我发现我对这个社会了解太少了，因为互联网的高速发展，大量低质量的内容充斥在互联网，而我们又缺乏分辨真假的能力，所以感觉无从下手，想来想去能够发掘的也就只有自己了。 人生本来就是一场游戏，社会是大家都在玩交叉而形成的世界，就像很多游戏一样，有些人天资聪颖，有些人生来就是领导，要想玩好这个游戏，我们就必须理解这个游戏，但是因为眼界的问题，我们无法理解整个游戏的世界观，但是我们可以分析眼前的资源，就是当前的你，你所拥有的技能，你的缺点，你的优点，你当前能够利用的资源，以及你搜集资源的能力，都是你以后生活的基础。 所以就有了下面的分析，并找到方法进行改正。 我的缺点：沟通技巧不足，经常词不达意，说话没有重点，就是有话堵在嘴边，不能用语言表达。同时对别人讲的话有时不能够完全理解，好像不在同一条线上。还有就是不自信，明明知道知道一些事情，不敢表达出来。缺乏归纳总结的能力。最近的感觉：之前还可以静下心来研究一些东西，现在经常会有压力，有压力就很难进入状态，静不下心来。心中有事的话晚上就睡不着，有些焦虑。 当然这些都是不足的，因为一个人是多维的，我们看到的只是当前某个维度的自己，怎么去看完整的自己？可以去做一些性格评测，这些东西虽然让人难以琢磨，但是毕竟研究了这么长时间，肯定是值得参考的，比我们自己研究要来的实际和效率。 这里有一点要领悟到就是我们要用最小的资源最短的时间实现自己的目标。 做一下评测就可以大概知道自己到底是哪方面的性格，顺便说一下我属于传统型和艺术性的，智商是文理各半比较平衡的那种。 我们买很多东西因为自身资源的不足，都会考虑到”性价比”，认识自己提升自己也是这样的一个过程，首先是认识自己，看到自己长处和短处，性价比指明了当前做出哪些改变能够收到最大收益。 怎么让自己的选择有性价比呢？ 首先就离不开前面的认识自己，了解了自己大概的性格，然后就是做分析。 做分析之前先聊一聊我看到的一些谈论，”外向和内向都各自有各自的优势，外向的人善于沟通，内向的人安静善于做细致的工作”，对于这种言论你怎么看，就和”无论什么颜色种族的人，在美国都不会被歧视”一样，但是工作歧视依然存在每个角落里。 这个社会是有色的，是一个过滤器，这个社会会将喜好的那一部分呈现在这个社会的上部分。 目前社会是一个资源导向型占据主导地位的商业模式。 对于一个人来讲，他具有资源统筹能力是能够在这个社会更好发展的。这些人能够聚拢资源，产生价值，然后强化他自身或者影响了更多的人。有远见，能够把资源放对地方（投资）。 所有有些技能是必备的。是这个社会的方向和阶段决定的。而有些是能在某个领域发挥较大作用的，就会有方向的选择。 我在翻阅了大量的文章之后，发现一些技能是必须的： 沟通文字归纳整理表达思想为人处世 人生是一场修行(二)上次谈到我对个人发展的一些理解，其中比较看重的沟通能力， 人性的弱点 一个人的成功，只有15%归结于他的专业知识，另外的85%要归结于他的表达思想、领导他人及唤起他人热情的能力 –戴尔·卡耐基 自我了解和发现是一个漫长的过程，一个人的成长和他的家庭，生长环境，以及人的本性是离不开的。 所以我首先想到的是了解人类的本性，其次是和家里人沟通，和亲人沟通，这是我们沟通技能很欠缺的根本原因。 然后就找到了一本戴尔·卡耐基写的《人性的弱点》，这里有我最想知道的与人相处的基本技巧。 如欲采蜜，勿蹴蜂房 尽量去了解别人，而不要用责骂的方式。尽量设身处地去想，他们为什么要这样做。这比批评、责怪更有益，而且让人心生同情、忍耐和仁慈。批评不但不会改变事实，反而会招致愤恨。因批评而引起的羞愤，常常使雇员、亲人和朋友的情绪大为低落，并且对应该矫正的现实状况，一点作用也没有。 在事实已经发生的时候，找出错误解决问题才是正途，批评指责只会浪费时间。 真心诚意的赞赏他人 在你每天的生活之旅中，被忘了为人间留下一点赞美的温馨，这一点小火花会燃起友谊的火焰。在日常的生活中，我们经常忽略的美德之一便是赞美他人。我们接触的是人，他们都渴望被人赞美，给他人以快乐，这是合情合理的一种美德。 这让我想起了之前比较火的夸夸群，人人都需要被赞美，而赞美别人又是一种艺术、一种美德，何乐而不为？ 我们供养我们的孩子、参与朋友以及同事的生活，而对他们自尊心的关注却少的可怜，也不知道应该给他们以赞赏的语言。而这恰恰就是生活中的晨曲，将会永远地埋藏在人们的心灵深处。 在这个世界上，只有一个方法能让任何人去做任何事–你是否静下心来想过这一点呢？确实，只有一个方法，那就是让这个人做事者愿意去做那件事。 我能够促使别人做任何事的唯一方法，就是尽量满足他们的需求。 那么，人们需要什么呢？ 健康与生命的保障(就医)食物(吃饭)睡眠金钱以及金钱能够买到的东西(奢侈品)长寿性欲的满足父母子女的幸福显要感(炫耀、装x、满足)(社交、人的大部分心理活动) 每个人都喜欢别人恭维自己。 每个人获取显要感的方式，就能够知道他大概是什么样的人，因为这是你生活中最重要的事情。 精神失常的人能够在自己的精神世界获取显要感，和你我相比要更加快乐，甚至有许多人更愿意装疯卖傻而从中取乐。 我们为我们的孩子、朋友和雇员提供牛排、土豆，以增加他们的体力，但我们却不知道给他们以赞赏的语言。 只要你”诚于嘉许了，宽于称道“，人们便会视你每一句话为珍宝，终生不忘，即使你自己早已经忘到九霄云外了，但别人仍然会铭记在心。 待人处事技巧：看到别人的有点，真心诚意地赞赏他人。 欲钓鱼，先设美味的饵 天底下只有一种方法可以影响他人，就是提出他们的需要，并让他们知道怎么去获得。成功的人际关系在于你捕捉对方观点的能力。同时，你还要兼顾你和对方的不同角度。能设身处地为他人着想，了解别人心里想些什么的人，就永远不用担心未来。 行动实际上是出于我们本身的基本欲望…无论是在商业、家庭还是商业中，或者是政治中，对那些想要劝导别人的人而言，我所能给他们的最好的建议，就是首先要把我对方最迫切的欲求。 也许你打算劝某个人去做某件事。在你开口之前，不防先问问自己：”我怎么才能使他心甘情愿地’要’做这件事呢？”，这个问题至少不会让我们冒冒失失地区同别人谈论自己的各种愿望。 如果成功有什么秘诀的话，那就是站在对方的立场来看待问题，如同用你自己的观点看事情一样，同时具备审时度势的能力。 人生是一场修行(三)如何使人喜欢你让人喜欢你，这里提高的是自己的个人修养。 如果你希望成为一个善于谈话的人，那就先做一个喜欢倾听的人。即使始终挑剔的人，甚至是最激烈的批评者，也常常会在一个有忍耐力和共情心得倾听者面前软化。 发至内心地关怀他人 凡不关心他人的人，必会在有生之年遇到重大的困难, 并且大大伤害到其他人。也就是这种人，导致了人类的种种错失。关心他人与其他人际关系的原则一样，必须出于真诚。不仅付出关心的人应该这样，接受关系人也理应如此。要对他人表示你的关心，这与其他的人际关系是同样的道理，但是，你的这种关心必须出自真心。 为什么通过读这本书来学习如何获得朋友呢?为什么不向世界上最善于交朋友的人学习这种技巧呢？狗，当你走到与他相距不远的地方时，它会开始摇尾巴；如果你停下来轻轻抚摸它，它就会异常高兴的跳起来，向你表示它是多么地喜欢你。而且你也知道，在这种亲热的背后，并没有其他的目的：它并不是想将一块地产推销给你，也不是想要和你结婚。 如果一个人真的关心别人，那他在两个月内所交到的朋友，要比总想使别人关心他的人，在两年内所交的朋友还要多。当然，有的人一辈子都难以领悟到，而总是想让别人对他们表示关心。 如果我们想要交朋友，就要用热情和活力去面对别人。当你和别人聊天打电话、工作时都要表现出你说怎么喜欢和他一起共事。 要想别人喜欢你的第一原则：要真诚地关心他人！ 别忘记带上你的微笑 行为胜于言论，对人微笑就是向他人表明：“我喜欢你，你使我快乐，我喜欢见你”。世上的人们都在寻找快乐，但只有一个行之有效的方法，那就是控制你的思想。快乐不在乎外界的情况，而是依靠内心的情况。 记得高中时我们学校有一个唯一的心理老师，每星期都会有一节心理课程，只有高三才有这个待遇。每次上课的时候都很轻松愉悦，他从进门开始就面带微笑，讲着各种各样的小故事，惹得大家开心。一节课45分钟感觉每分钟都是那么愉悦，他就是面带微笑，一直讲，直到下课。当时就觉得这个心理老师的口才很是了得，讲的一些小故事都是恰到好处，所有人都不会反感。 如果你想要别人喜欢你，请带上你的微笑。 如果你希望别人看到你的时候很愉悦，你一定要记住：当你看见别人的时候，一定要心情愉悦。(怎么愉悦，心情是由思想控制的，所以要控制思想) 牢记他人的姓名 一种最简单、最明显、最重要的获得好感的方法，就是记住他人的姓名，使他人感觉自己对于别人很重要。记忆姓名的能力在事业与交际上，和在政治上差不多同等重要。多数人不记得姓名,只因为他们没有下功夫去记。 小时候我们交朋友的第一句话就是介绍自己的名字，到现在一直没变。 记住一个人的姓名，并且很容易就叫出来，对人来说可是一种很巧妙而很有效的恭维。(显要感的来源) 既然人们是如此地重视他们自己的名字，因此他们一般都会尽量设法，使之得以世代延续下去而永垂不朽。 作为一名政治家，所学的第一堂课就是记住选民的姓名。 学会倾听他人讲话 如果你希望成为一个善于谈话的人，那就先做一个喜欢倾听的人。即使始终挑剔的人，甚至是最激烈的批评者，也常常会在一个有忍耐力和共情心得倾听者面前软化。不要忘记和你谈话的人，对他自己、他的需求、他的问题，比对你和你的问题要感兴趣100倍。 倾听？像看书一样要画出重点，哪些是他的需求、他的问题、他的观点。这样就很能找到谈话的重点，get他的G点。 谈论他人感兴趣的话题来了！怎么知道别人感兴趣，还是要倾听他说的话、观察他的行为。 与人沟通的诀窍就是：了解对方的兴趣，谈论他感兴趣的事。 谈论使对方注意并且高兴的话题能使自己成为一个受欢迎的人。 让他人感觉到自己的重要性 你要别人怎么待你，你就得先怎样对待别人。你希望得到朋友的认同，那就需要让别人知道你的价值。你希望在自己的生活世界里有一种自己对别人很重要的感觉，那就先处处关心别人。(这个世界还有人关心你，乐意与你叫朋友) 人类的行为有一个极为重要的法则：时时让别人感到重要。 当代人以自我为中心的生活常态，满足他们的需求，给他们以肯定，你将获得财富。 ## 如果不学，那么你永远只能知道别人想让你知道的信息。 微信”再看” 朋友圈中，别人在做什么，有相同爱好的人，才会走到一起。 社交模块深藏于社会之下的蛛网 社交是人类的本能 利用社交来进行沟通 偏感性，在最脆弱的时候切入 如何和上司成为更好的朋友? 腾讯，社交 得到社交 互联网产品玩的都是人性 社交最难 流量源源不断的 陌陌：约炮起家 小吃摊加社交 战略（产品的买点、什么用户、哪块市场、市场方向）、战术(就是战略的具体)、运作() 管理学 社交属性 人脉图表 行业 哪些是需要维护的 沟通的时间、现在工作的地方 吃个饭 每个城市的规划 黄色，住宅区，大面积住宅区不是有升值的 商业区 经济部分 贷款 ##996和人生奋斗的混淆：当然，也不是说955就是悠闲，很多人下班之后可以做更高效的努力赚的币工作上的还多，而很多人在996上工作效率也未必见得有多高。为什么资本家总要混淆这个概念？因为这可以保证你时间和空间的范围里你是待在公司里的，就提升一些你为公司提供剩余价值的几率。 给自己打工和出卖时间的混淆：我之前说过，我自己愿意007，和马云一样愿意12127，为啥，因为我做的东西是给自己做的，说的难听一点，我生产出来的东西以后都是我自己的生产资料，没人剥削我，所有的东西都是我自己的，那么我奋斗到天荒地老也没人同情，就和第一条一样，但是有一点不同的是，当代互联网已经过了那个阶段了，现在的行情是“毕业两年左右在互联网工作两年左右的人，拿着非常少的期权，给那些拿了大量期权的加不动班的中层打工” 无论投资人、创始人、媒体怎么说，我们不能否认，这个阶段的互联网，已经没法提供与996相匹配的成就感、公司归属感、社会财富了。而这才是最近996被拿出来说的最直接原因。 风险和收益不对等了。15年或者16年之前，加入互联网，不顾身体拼死拼活后，说不定能拿超额的期权，公司变现了之后，自己也算是公司的一个百分比的主人了，财富上的回报，也跟着公司成长了，抱团了，成了中层了。就不用那么累了。 但是现在进去都是之前那一波出来的了，当公司稳定发展后，没有什么不顾身体拼死拼活对等的回报了。无非是工资高一点，而这已经是全部了。归属感、成就感，和你没有半毛钱关系。 当收益不行的时候，风险反而在加剧，正是因为行业到了瓶颈，开始缓慢，受到惯性的压迫下，互联网公司的压榨反而会更高，而对年轻人产生更高的时间索取，出现反抗是必然的事情。 所以这种“修来的福报”，是给阿里的十八罗汉说的，是给他们那些合伙人，甚至总监说的，这是实在话，半年一加薪，一年一升职，三年上总监，期权拿的飞起，说实在的你在其他地方很难得，这帮人拼死拼活付出时间，至少是有回报的。 但是对于如果对所有人说是“福报”，那就问题大了，对于这两年进入阿里的人来说，这只是相对于其他地方比较高的价值换取。 现金流的重要性最近是美股出报表的日子，其实挺有意思的，看各家公司的报表往往能看出很多事情。 比如Netflix和Amazon就是完全两种不同风格的报表逻辑，前者低流动性、高成本滚动的玩法，后者是大现金流低利润的玩法，怎么说呢，就像一个卡车和一个电动车的区别一样，很有意思。 人生其实也一样，有各种各样的自己的“人生报表”的模式，有的人有特别好的所有者权益、但是没有好的增长，有的人一穷二白负债累累，但是越负债越吃香，其实挺有意思的。 对很多人来说，现金流往往比利润更重要，特别是前期的学生时代还有工作前几年的时候，但很多没有商科底子思维的人往往意识不到这一点，甚至很多商科毕业的人也没法从这里面学到做人的道理。 今天随便讲讲，看了不吃亏。 1 我记得还在大学时候，《会计学基础》的核心逻辑我看了很久，而且看的很舒服。因为这种基础书非常有用，很多底层思维不但看的快、而且用处多，性价比非常高。 很多学商科的人都不懂为什么大一非要学这本书又不是真的搞会计的。 其实这种基础书，往往都是由浅入深的，没有你想的那么难，你只要看进去，去抓住这种思维逻辑为自己所用就可以了。 很多人肯定会困惑：我想赚钱，我想成功，看书有什么用？逻辑就在这里：并不是说让你非要当会计才要看这种书，这种看的快、容易理解又用处多的书，你看几遍只要不笨，基本上其中很多思维你都能活学活用到人生里面，短期你看不到钱，但是长期来看大有裨益。 类似的还有心理学基础等等，其实非常有用。 比如说企业有三张报表，咱们说赚的钱很重要，利润表。你有多少资产和负债很重要，资产负债表，那为什么现金流量表要单拿出来做一个表呢？其实这个很有意思，现金流，除了提供流动性溢价还能提供啥呢？ 还可以提供很多隐性的好处，这些能让你在商业社会里占到很多便宜。 比如亚马逊和苹果的现金流特别充裕，他们就更容易去获得优质贷款。你现金流足够好，你的银行常规贷款，还有可转债都会非常便宜。这无形中就会让你占到很大便宜。 大家可能会问，你有那么多钱还借什么钱啊？除了我之前说过的和经济绑定站在一条船上的做法之外，除了那些速动和流动比率外，最主要的就是，因为规模性，你同时占据优质现金流和低成本的贷款后，你未来能占的便宜就会更多。 人心里都会按照常规思维算账。我有100万现金流，一年之后我通过努力可以达成年化10%的回报，变成110万。 但企业家的思维是100万现金流继续不变甚至我都不动，但是我又去借100万的4%成本的钱，最后这100万你只能赚里面的6%也就是你最后手里还了钱之后是106万。 按照大部分小农思维肯定会觉得利润更重要选择前者，但不好意思，80%的企业都羡慕后者，甚至，哪怕最后你没赚6%，你只赚了2%，很多企业都愿意。 为啥？为啥赚钱不好？省钱也不好？ 就是因为你能占足便宜。因为你手里那不动的100万可以让你有更多风险偏好、让你面对上下游看供应链回款的时候有更多底气、让外部投资和风险机构更容易帮你找到便宜的钱。 在这个社会中，你能占到的合理的便宜越多，你便越能够让自己更游刃有余的面对危机和竞争。 前段时间某篇文章说过的，亚马逊拿到的债的成本，甚至都不是4%，有一段时间，甚至是不到1%，和白送一样。就是因为其本身靠着充足的现金流占尽了便宜。 这点非常有意思，很多时候，钱放着本身就值钱，它带来的溢价远超你的想象。很多时候，负债甚至是你在占便宜，很多时候，亏损甚至比赚钱更让人舒坦，很多时候，只有长久的亏损才能带来后面巨额的回报。 这些和最纯粹的大众的生意理念很多都是相悖的，很有意思。你会发现生活中很多事情一模一样。所以说做一个企业的过程里你会学到很多东西，这些都会慢慢让你的人生变得不一样。 2 很多人无法理解“现金流大于利润”这一逻辑，总想着落袋为安追求眼前利益，那结果就是你一辈子都在被别人占便宜，一辈子都在吃亏。 比如说很多人嘴很毒，说话特别难听，这种人往往其实就是为了满足一时的心里痛快，想让这个时间点的“利润”尽快在心里变现，但是却让自己的人生的现金流变得很差劲，以后就会吃大亏。但是下一次还是不能吸取教训，还是嘴损，因为它不这么说心里就不舒坦，慢慢的就变成总渴望追求当下的满足，然后一辈子吃亏。 一个嘴损的人会吃什么亏？可能你走这一路会丢掉很多本可以互相搀扶往前走的朋友，可能会让你的孩子产生自卑自负等等问题，可能慢慢让自己越来越孤独，这个世界上很多机会都会离你远去。不信你去看看那些一事无成的人，往往嘴比谁都狠，也比谁都松。 这几天有个挺让人心碎的新闻不知道大家看那个视频没有，一个17岁孩子在学校和别人闹矛盾，当妈的直接开车停在路上，来来往往都是车辆也不管，就开始说孩子，说了一段时间之后孩子直接开车门从旁边桥上跳下去了。没救过来。挺让人难过的。 不要什么事情都为了一时的心里痛快，就像是做什么事情都渴望马上带来利润，而忽视了长远的现金流。 或者又比如 前段时间有个朋友也在问我，说有了进BW的工作机会，但是工资太少了，我相信如果商科学的好感悟深是不会问出这种问题的。我说你不要想着马上变现当下的利润，bw给你的这种巨大的流动性溢价你是难以想象的，就像亚马逊和苹果的报表一样，它能给你带来你想象不到的低成本的贷款（在现实生活里就是不需要付出多少精力便可以得到的超高质量的人脉、机会、见识等等），给你带来撬动后面更大规模的底气。 这种地方的流动性溢价是非常大的，因为只要是个人就有很大概率觉得，加你微信也不错，甚至会主动来找你加微信，而如果你只是为了当下的利润，你回头过几年再想拿到社会里这种“低成本的贷款和资源”会难上加难。 不信的话，现在在互联网公司996工作的朋友们，我相信当你开始面对公司内斗站队的时候，开始面对当年那些工资只有你三分之一的体制内的朋友如今稳扎稳打往前走的样子，你一定会曾经后悔过，但你永远无法再去获得这些低成本的贷款和资源了，就像公司一样，当你前期只追求利润不追求现金流流动性用来撬动更便宜的规模的时候，你这一辈子终究只能活在别人的规模之下了。也就是说，你这辈子再也难以获得这些低成本的资源了。 当然这种资源能不能用，怎么用，那就是个人的问题了，很多好企业现金流那么充裕过几年不还是破产了。就像你好好吃饭自律运动，你有可能会有很好的身体，但是你不好好吃饭不运动，你很大概率就没有好身体。 包括为什么很多企业宁可不要利润？合理税务筹划是一码事，另一码事其实就是一种长远利益的思维在里面。贪小便宜就会吃大亏，很多时候我们总瞧不起那种年轻的时候特别活跃的人啊，年轻时候明明可以赚的东西却不赚的人啊，这不是傻，也不是没脑子，其实很多时候这就是一种舍弃利润换取长远规划的做法。别瞧不起你部门里或者你班级里那个最活跃的人。 挺有意思的其实，企业都是社会的一份子，做一个企业有多少坑，做人就有多少坑。很多时候企业规划也会从社会大趋势里总结经验，所以为啥有三张报表不是10张呢？其实就是这样。包括企业的KPI和OKR法啊等等也一样，都是一种总结。 类似的还有啥，前几年那一拨拉高估值的大并购，往往卖出去的都是那些活跃和欢实的公司，却往往并不是那些利润高的，为啥啊？一样的道理。 所以很多时候别怕向外面展示自己的内在（当然是前提你要有），这个世界越来越多的注意力已经被手机上各式各样直攻你心的东西占据着了，更不要期待别人主动来认识你和联络你。但资源、机会、永远不会只存在于线上，永远都有一个落地的过程。 让自己变得积极点，活泼点，在这个过程里哪怕会有很多噪音在，你依然会抓住更多的信号。某种意义上，这也是一种现金流的社会表达吧！ 动起来。只注重利润而忽视现金流的公司往往最后都没啥意思，但世界不会亏待真正用心经营自己的人，但用心经营自己并不是闷头跟着大众理论走，你要去发现那些更高效的东西， 当你学会占人生的便宜，慢慢就会发现人生的那些经营到底是什么意思了，当然这里的便宜可不是小便宜。 给自己一个小目标，今晚就把会计学基础看完吧~别告诉我这本书你都借不到]]></content>
      <categories>
        <category>人性</category>
      </categories>
      <tags>
        <tag>软实力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-element-admin]]></title>
    <url>%2F2019%2F02%2F25%2Fvue-element-admin%2F</url>
    <content type="text"><![CDATA[vue-element-admin的使用总结 基础基于vue2.0,配合使用 Element UI 组件库的一个前端管理后台集成解决方案. 优点：1.权限验证方案。通过配置不同的角色展示不同的页面，可以前后端配合用于权限配置。2.和element-ui有配套的组件，基本满足了项目的需求，而且是大团队在维护便于项目开发和问题解决。 页面布局layout作为内容页基础模板，所有的页面跳转都是在这里完成的。包含导航、侧边栏、面包屑以及内容。可以根据自己的需求创建一级模板layout。通过嵌套路由只更新页面appmain和导航栏、侧边栏的数据。点击侧边栏通过重定向redirect: &#39;/site/index&#39;切换到当前路径下的默认页面。侧边栏基于element-ui和el-menu改造 权限验证思路：通过获取当前用户的权限，然后去对比路由表，生成当前用户具有的权限可访问路由表，然后通过router.addRoutes动态挂载到router上。 问题]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-element-admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目]]></title>
    <url>%2F2019%2F02%2F21%2Fxm%2F</url>
    <content type="text"><![CDATA[项目心得以及注意事项 表单：1.字段对应的校验，并且在该字段对应出现的位置要同步校验。 版本更新由于文件不同引起的功能差异api文档：https://swagger.io/静态书籍：https://easy-mock.com/login 输入内容校验的问题输入内容只用于展示的问题，将内容转义，或者innerText 全栈应该是能理解整个产品的命脉，并把它最终实现出来，安全运行。 目前项目当中依然存在的问题：SEO方面 1.核心功能是方便用户分享和阅读，分享链接尽量简洁，但是和域名绑定的只有一个参数，资源有限，只能选择其一，将分享链接设置为通过域名+参数就能访问。（未实现） 2.各个页面title可以在优化一下，比如说确定这个页面的关键信息。 3.每个页面都没有关键词。 4.阅读页面现在是异步加载的数据，改成同步渲染。安全运行方面 1.数据库备份 2.必要时可以做均衡负载（条件以及如何实现） 3.静态文件cdn（部分实现）,以及文件大小,减少带宽占用 4.了解常见的安全防御措施以及加固方法，并添加到项目中。功能方面 核心功能编辑和阅读优化，添加常见的编辑格式支持，提高用户体验。想做的事情：了解当前市场上面成型的方案，建立自己的方便前后端流程化开发和交付测试的工具功能方面：用户和书籍的关系、展示以及查询还未完成，书籍分类划分，方面用户查阅书籍 关于做项目的思考首先，你要转变思维，如何从用户的角度出发，从用户体验做深入思考。如何从设计和功能上提高用户体验，以及功能背后的目的。其次，之前一个人能把事情做得很好，现在怎么保证团队一群人把它做好？任务分配包括如何把任务合理地分配给适合的人，能达到最好的结果，即人的价值得以体现，产出质量也高。这就要求管理者对任务的了解要全面深入，对团队每个人的能力了解也要准确。然后，要听听别人的意见，大家一起讨论，注重沟通，了解学习相似的网站。最后，是要理解产品的本质，然后把它实现出来，并且安全运行。 自定义组件库工具维护使用]]></content>
      <tags>
        <tag>项目心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-html]]></title>
    <url>%2F2019%2F02%2F20%2Fjs-html%2F</url>
    <content type="text"><![CDATA[html常用标签的使用与总结 首先要了解的概念块级元素和内联元素123块级元素在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，例如段落、列表、导航菜单、页脚等等。一个以`block`形式展现的块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。内联元素通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素`&lt;a&gt;`或者强调元素`&lt;em&gt;`和 `&lt;strong&gt;`。 head元素内部base标签1234567891011121314151617181920&lt;base&gt; 标签为页面上的所有的相对链接规定默认 URL 或默认目标。在一个文档中，最多能使用一个 &lt;base&gt; 元素。&lt;base&gt; 标签必须位于 &lt;head&gt; 元素内部。示例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;base href=&quot;http://www.runoob.com//images/&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img src=&quot;logo.png&quot; &gt; - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签，该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 &quot;http://www.runoob.com/images/logo.png&quot;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/&quot;&gt;runoob.com&lt;/a&gt; - 注意这个链接会在新窗口打开，即便它没有 target=&quot;_blank&quot; 属性。因为在 base 标签里我们已经设置了 target 属性的值为 &quot;_blank&quot;。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 示例链接注：base 会默认将base的链接和src、url链接拼接 meta123456用来描述文档的作者、描述、关键字、字符集等等name的关键字有`author` `keywords` `description` &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; 小知识点：每个30秒刷新页面1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; title1文字的标题 12345定义客户端脚本如果 async=&quot;async&quot;：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）如果不使用 async 且 defer=&quot;defer&quot;：脚本将在页面完成解析时执行如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本 1&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-regexp]]></title>
    <url>%2F2019%2F02%2F15%2Fjs-regexp%2F</url>
    <content type="text"><![CDATA[常用正则表达式 匹配域名12^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]&#123;0,61&#125;[a-zA-Z0-9])?\.)+[a-zA-Z]&#123;2,6&#125;(/)该表达式可以匹配以http://或者https://开头且支持域名中有中划线的情况，并且会匹配到域名后的第一个/. 匹配 26个英文字母 0-9数字 和 小数点/[a-zA-Z0-9.]/ 特殊字符$ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。+ 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。. 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。[ 标记一个中括号表达式的开始。要匹配 [，请使用 [。? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(“。]]></content>
      <categories>
        <category>JavaScript, Regexp</category>
      </categories>
      <tags>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-dom]]></title>
    <url>%2F2019%2F02%2F14%2Fjs-dom%2F</url>
    <content type="text"><![CDATA[性能提升小技巧 减少dom操作]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>dom操作性能提升</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F13%2Fcss%2Fcss3%2F</url>
    <content type="text"><![CDATA[Document .radius{ width: 100px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ /* border-radius: 100px 50px; */ /* border-top-right-radius: 100px 50px; */ border-radius: 100px 0 0 100px; } /* 添加过渡效果 */ /* -webkit-,-o- */ .circle{ background-color: aqua; width: 50px; height: 50px; border-radius: 50%; transition: all 0.5s; } /* 缩放1.5倍 */ .circle:hover{ transform: scale(1.5); } .nth ul{ list-style: none; } .nth li{ width: 20px; height: 20px; border: 1px solid #666; } .nth a{ display: block; width: 20px; height: 20px; text-align: center; border-radius: 50%; background-color: aquamarine; } /* .nth li:nth-child(n){background-color: black;} */ /* .nth li:nth-child(2n){background-color: black;} */ /* .nth li:nth-child(2n+1){background-color: black;} */ .nth li:nth-child(n+5){background-color: black;} 1 2 3 4 5 6 7 8 9 0 .after::after{ content: '*'; color: red; } .after::before{ content: '&'; color: #666; } .letter::first-letter{ font-size: 35px; color: crimson; font-weight: bold; float: left; } /* 添加float:left首个文字就会下沉 */ .letter::first-line{ color: #f66 } /* 首行 */ 我是一句话额！ .dialog{ width: 200px; height: 50px; line-height: 50px; background-color: #f66; border-radius: 6px; position: relative; } .dialog::before{ content: ''; border-width: 10px; border-color: transparent; border-style: solid; border-right: 10px solid #f66; position: absolute; top: 15px; left: -20px; } .triangle{ width: 0; height: 0px; border-right: 50px solid #f66; border-left: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid transparent; } 我的小姐姐呢 .diamond{ width: 200px; height: 200px; -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); background-color: aqua; } .parallel{ width: 300px; height: 200px; -ms-transform: skewX(45deg); -moz-transform: skewX(45deg); -webkit-transform: skewX(45deg); -o-transform: skewX(45deg); transform: skewX(45deg); background-color: aqua; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F01%2F24%2Fvue%2F</url>
    <content type="text"><![CDATA[记录vue的知识点 重点vue的双向绑定？怎么实现的？vue响应式原理vue内部使用Object.defineProperty()来实现数据响应式，通过这个函数将vue实例data对象的所有属性全部转为getter/setter。然后在属性被访问和修改时通知变化。监听这个变化的是watcher实例对象，在渲染组件的过程中把属性记录为依赖，在setter被调用时，会通知watcher重新计算，从而导致它关联的组件更新。 JavaScript 的限制 ( Object.observe 已经被废弃)，Vue 不能检测到对象属性的添加或删除。所以属性必须在data对象上存在才能让Vue转化它。 可以通过Vue.set(object, key, value)添加到data(或者其他对象)对象上实现响应式还可以使用vm.$set 实例方法，这也是全局 Vue.set 方法的别名：1this.$set(this.someObject,&apos;b&apos;,2) 虚拟dom?怎么实现的？声明式渲染模板语法插值 12345vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统。&#123;&#123; 参数|单个表达式 &#125;&#125;单个表达式包括：运算、三目运算&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; // 将字符串翻转 vue的生命周期beforeCreate // 实例初始化之后，数据观测和事件配置之前，也就是说这时候是不能获取数据和事件的created // 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。beforeMount // 在挂载开始之前被调用：相关的 render 函数首次被调用。mounted // el 被新创建的vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。beforeUpdate // 数据更新前updated // 数据更新后beforeDestroy // 销毁之前 适合移除时间、定时器 可能会引起内存泄漏destroyed // 销毁 在销毁组件，如果有子组件的话，会递归销毁子组件，直到所有的子组件都销毁完毕之后执行 v-show12`v-show`始终渲染元素，通过切换display来控制元素的显示隐藏，有较大的初始渲染开销。注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。 v-if1`v-if`指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染。 v-model1实现双向绑定 可以添加修饰符 .trim123如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：`&lt;input v-model.trim=&quot;msg&quot;&gt;` .number12345如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：`&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;`这通常很有用，因为即使在 `type=&quot;number&quot;` 时，`HTML` 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。(说明`number`的实现是通过`parseFloat()`方法实现的) .lazy12在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 。添加`lazy`从而转变为使用`change`时间进行同步，也就是在每次改变的时候进行同步。 v-once1只赋值一次 事件修饰符.prevent12`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 计算属性语法123456789101112&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;computed:&#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; // 关键字computed，是vue的一个属性 计算属性的setter12345678910111213141516计算属性默认只有getter,不过在需要时你也可以提供一个settercomputed: &#123; fullName: &#123; // 计算属性 // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;现在再运行 vm.fullName = &apos;John Doe&apos; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 目的：替换模板语法的复杂逻辑 计算属性缓存 vs 方法123456789最终结果是完全相同的。不同的计算属性是基于他们的依赖进行缓存的。只有在相应的依赖发生改变时计算属性才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。调用方法总会再次执行函数。computed: &#123; now: function () &#123; return Date.now() &#125;&#125;// 只会返回第一次的时间。 计算属性 vs 倾听属性12345678910111213141516171819vue提供了一种更通用的方式观察和响应vue实例上的数据变化。当你有一些数据需要随着其他数据的变化而变化时，很容易滥用watch,通常使用computed。var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; // 监听某个数据改变 this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 倾听器vuex$nextTick1将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-api]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-api%2F</url>
    <content type="text"><![CDATA[用于平常学到的js知识点 Array.prototype.includesmdn 语法：12345arr.includes(searchElement)arr.includes(searchElement, fromIndex)返回值：Boolean 用于判断数组中是否存在某个值 includes() 作为一个通用方法includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的arguments对象上调用的includes() 方法。 1234(function() &#123; console.log([].includes.call(arguments, &apos;a&apos;)); // true console.log([].includes.call(arguments, &apos;d&apos;)); // false&#125;)(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); element.scrollIntoView() 让当前的元素滚动到浏览器窗口的可视区域语法123element.scrollIntoView(); // 等同于element.scrollIntoView(true) element.scrollIntoView(alignToTop); // Boolean型参数 element.scrollIntoView(scrollIntoViewOptions); // Object型参数 mdn 同源策略mdn(https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) 同源策略限制了从同一个源加载的文件和脚本如何同另一个源加载的文件进行交互。 同源的定义： 协议、端口、域名完全相同的两个页面，称这两个页面具有相同的源。 源的继承： about:blank]]></content>
      <tags>
        <tag>jsapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2019%2F01%2F17%2Fes6%2F</url>
    <content type="text"><![CDATA[es6笔记 let const var var 在全局作用域下声明变量会导致变量挂载在 window 上, let const 不会 let 声明的变量只在 let 命令所在的代码块内有效。 const 声明一个只读的常量，一旦声明，常量的值就不能改变。 let 只能声明一次 var 可以声明多次 let 不存在变量提升 const 声明一个只读变量，声明之后不允许改变。 12345678910111213for 循环计数器很适合用 letfor (var i = 0; i &lt; 10; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;)&#125;// 输出十个 10for (let j = 0; j &lt; 10; j++) &#123; setTimeout(function()&#123; console.log(j); &#125;)&#125;// 输出 12345... 变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。变量 j 是用 let 声明的，当前的 i 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。 变量提升英文：Hoisting 很有意思的题目 变量提升变量和函数的声明移动到当前执行上下文(块)的最前面。应用范围：数据类型、变量、函数 runtime：1.并不是物理位置的移动，而是在编译阶段被放到内存中。2.仅提升声明，而不提示初始化 历史原因：提升存在的根本原因就是为了解决函数间互相调用的情况 12345678910&#123; catName(&quot;Chloe&quot;); function catName(name) &#123; console.log(&quot;我的猫名叫 &quot; + name); &#125;&#125;catName(&quot;Tom&quot;);// 我的猫名叫 Chloe// 我的猫名叫 Tom 1234567function test1() &#123; test2()&#125;function test2() &#123; test1()&#125;test1() let 不存在 Hoistingvar 在全局作用域下声明变量会导致变量挂载在 window 上 tomdn 暂时性死区let、const 因为暂时性死区的原因，不能在声明前使用 在 ECMAScript 6 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 tomdn 12345var PI = &quot;a&quot;;if(true)&#123; console.log(PI); // ReferenceError: PI is not defined const PI = &quot;3.1415926&quot;;&#125; ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。 const 如何做到变量在声明初始化之后不允许改变的？保证变量指向的内存地址所保存的数据不被改变。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重 原型继承立即执行函数历史原因：用于模块化，通过函数作用域解决命名冲突、污染全局作用域的问题。1(function()&#123;&#125;)() 箭头函数（Arrow Function）没有自己的this,arguments,super或者new.target这些函数表达式更适用于那些本来需要匿名函数的地方，并且他们不能用作构造函数。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。应用场景： 当我们需要维护一个this上下文的时候比如1var self = this 不合适的场景：定义函数的方法，且该方法中包含this1234567891011121314151617181920var Person = &#123; &apos;age&apos;: 18, &apos;sayHello&apos;: ()=&gt;&#123; console.log(this.age); &#125;&#125;;var age = 20;Person.sayHello(); // 20// 此时 this 指向的是全局对象// 正常使用var Person1 = &#123; &apos;age&apos;: 18, &apos;sayHello&apos;: function () &#123; console.log(this.age); &#125;&#125;;var age = 20;Person1.sayHello(); // 18// 此时的 this 指向 Person1 对象 需要动态 this 的时候12345// 错误使用var button = document.getElementById(&apos;userClick&apos;);button.addEventListener(&apos;click&apos;, () =&gt; &#123; this.classList.toggle(&apos;on&apos;);&#125;); button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象 call apply bind语法call(this,…args) // args 参数列表apply(this, …args) // args 参数数组bind(this, …args) // 以上两种都支持 es5实现作用:重定义this 解构赋值它使得将值从数组，或属性从对象，提取到不同的变量中，成为可能为了方便从对象数组中提取需要的值… 剩余运算符 数组模型的解构 123456789var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50] 可忽略123let [a, ,b] = [1, 2, 3]// a=1// b=3 不完全解构1let [a=1, b]=[]; //a=1,b=undefined 字符串等在数组的结构中，结构的目标如果为可遍历对象，皆可进行结构赋值。可遍历对象即实现iterator接口的数据。1let [a, b, c, d, e] = &apos;hello&apos; 结构默认值当解构模式有匹配结果，且匹配结果是undefined时，会触发默认值作为返回结果。1let [a=3, b=a] = [] 12345678910(&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20// Stage 4（已完成）提案中的特性(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125; 模板字符串（Template String）对象字面量扩展语法（Enhanced Object Literals）表达式结构（Destructuring）函数参数表达、传参使用函数默认参数时，不允许有同名参数12345678910// 不报错function fn(name,name)&#123; console.log(name);&#125; // 报错 当使用默认参数时 //SyntaxError: Duplicate parameter name not allowed in this contextfunction fn(name,name,age=17)&#123; console.log(name+&quot;,&quot;+age);&#125; 什么时间使用默认参数：当参数为undefined时使用1234function fn(name, age=17)&#123; console.log(name+&quot;,&quot;+age);&#125;fn(&apos;Tom&apos;, null) // Tom,null 生效 函数参数默认值存在默认值死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值。12345678910function f(x,y=x)&#123; console.log(x,y);&#125;f(1); // 1 1 function f(x=y)&#123; console.log(x);&#125;f(); // ReferenceError: y is not defined// chrome 最近版本并不报错 ！！！ 不定参数不定参数用来表示不确定参数个数 …args 只能放在参数组的最后，而且只有一个打印出来是个Array123function fn(...args)&#123;&#125; 新的数据结构类语法（Classes）生成器Promise异步编程的一种解决方案从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 Promise 状态 pending(进行中) fulfilled(已成功) rejected(已失败) 无法改变这个状态。 Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。 状态机制的缺点 无法取消Promise, 一旦创建就会立即执行，无法中途取消. 如果不设置回调函数， Promise 内部抛出的错误， 不会反应到外部。 当处于 pending 状态时，无法得知目前进行到哪一个阶段了. then 方法then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调 resolve ，第二参数是 Promise 执行失败时的回调 reject，两个函数只会有一个被调用。 大多数浏览器不能终止的 Promise 链里的 rejection, 建议后面都跟上.catch(); 通过 .then 方法添加的回调函数，不论什么时候，都会被调用。 通过 .then 可以添加多个回调函数，他们会按照插入顺序并且独立运行。 .then 方法将返回一个 resolved 或者 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。 代码模块化特点 ES6的模块自动开启严格模式，不管你有没有在模块开头添加 use strict 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等 每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。 每一个模块只加载一次(单例)，若再去加载同目录下通文件，直接从内存中读取。 export 与 import 基本用法 导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 不仅能导出声明还能导出引用（例如函数）。export 命令可以出现在模块的任何位置，但必需处于模块顶层。import 命令会提升到整个模块的头部，首先执行。 export default 命令 重点 在一个文件或模块中，export、import 可以有多个，export default 仅有一个。 export default 中的 default 是对应的导出接口变量。 通过 export 方式导出，在导入时要加{ }，export default 则不需要。 export default 向外暴露的成员，可以使用任意变量来接收。 SymbolSE6 引入的一种新的原始数据类型 Symbol ,表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 Proxyfor of 替换 for…in1234567const Zootopia=[ &#123;name:&apos;Nick&apos;,gender:1,species:&apos;Fox&apos;&#125;, &#123;name:&apos;Judy&apos;,gender:0,species:&apos;Bunny&apos;&#125;];for(const &#123;name,species&#125; of Zootopia)&#123; console.log(`hi,I am $&#123;name&#125;,and I am a $&#123;species&#125;`);&#125; Array.forEachMap和SetMap 对象保存键值对。任何值（对象和原始值）都可以作为一个键或者值。 Map 和 Object 的区别 一个 Object 的键只能是字符串或者 Symbols ,但是一个 Map 的键可以是任意值。 Map 中键值是有序的，而添加到对象中的键则不是。 Map 的键值对个数可以从 size 中获取，而 Object 的键值对个数只能手动计算。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象的设置上的键名产生冲突。 api123456789101112131415161718192021222324252627Map.set(key, value)Map.get(key) // return valueMap.size // return 当前 Map 键值对个数Map.clear() // 清空键值对Map.delete(key) // 删除键值对 return 操作的结果？booleanMap.has(key) // 是否含有键值对 return 操作的结果？booleanMap.forEach((key, value)=&gt;&#123;&#125;)// set 可以是任何类型的唯一值Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复，只会生成一个键是0的键值对undefined 与 undefined 是恒等的，所以不重复；NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。// to arrayArray.from(map) // 根据键值对转换成数组// clonevar newmap = new Map(oldmap) // 每次都会迭代一个新的对象// concat 合并var first = new Map([[1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);var second = new Map([[1, &apos;uno&apos;], [2, &apos;dos&apos;]]); // 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， threevar merged = new Map([...first, ...second]); 遍历方法1234567891011121314151617181920212223242526272829var mymap = new Map();myMap.set(0, &quot;zero&quot;);myMap.set(1, &quot;one&quot;);for (var [key, value] of myMap) &#123; console.log(key + &quot; = &quot; + value);&#125; // 0 = zero// 1 = onefor (var [key, value] of myMap.entries()) &#123; console.log(key + &quot; = &quot; + value);&#125;// 同上/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */// entry 条目/项、输入、河口 entries// Iterator 迭代器// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;for (var key of myMap.keys()) &#123; console.log(key);&#125;/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */ // 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;for (var value of myMap.values()) &#123; console.log(value);&#125;/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */ Set 允许你存储任何类型的唯一值，无论是原始值还是对象引用Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待： +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；undefined 与 undefined 是恒等的，所以不重复；NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。 字符串判断字符串是否包含子串使用 indexOf() lastIndexOf()新增123String.includes(str) // return booleanString.startsWith(str) // return boolean 判断参数字符串是否在原字符串的头部String.endsWith(str) // return boolean 判断参数字符串是否在原字符串的尾部 字符串重复1234String.repeat(val) // 返回新的字符串，表示将字符串重复指定次数返回。// val // 向下取整 3.2 -&gt; 3// NaN -&gt; 0 字符串补全模板字符串1`123`&amp;&#123;myvar&#125; // &#123;&#125;可以放表达式 对象属性直接写变量，这时候属性名是变量名，属性值是变量值。123456const age = 12;const name = &quot;Amy&quot;;const person = &#123;age, name&#125;;person //&#123;age: 12, name: &quot;Amy&quot;&#125;//等同于const person = &#123;age: age, name: name&#125; 方法名也可以简写123456const person = &#123; sayHi()&#123; console.log(&quot;hi&quot;); &#125;&#125;person.sayHi(); 如果是Generator函数，则要在前面加一个星号1234567891011const obj = &#123; * myGenerator() &#123; yield &apos;hello world&apos;; &#125;&#125;;//等同于const obj = &#123; myGenerator: function* () &#123; yield &apos;hello world&apos;; &#125;&#125;; // generator 发电机 使用剩余运算符浅拷贝对象 (…) 浅拷贝1234let person = &#123;name: &quot;Amy&quot;, age: 15, eat()&#123; console.log(&apos;I am eating&apos;)&#125;&#125;;let someone = &#123; ...person &#125;;someone; //&#123;name: &quot;Amy&quot;, age: 15, eat()&#123; console.log(&apos;I am eating&apos;)&#125;&#125;someone.eat(); // I am eating 合并对象1234let age = &#123;age: 15&#125;;let name = &#123;name: &quot;Amy&quot;&#125;;let person = &#123;...age, ...name&#125;;person; //&#123;age: 15, name: &quot;Amy&quot;&#125; 自定义的属性和拓展运算符对象里面属性的相同的时候：自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。123let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;let someone = &#123; ...person, name: &quot;Mike&quot;, age: 17&#125;;someone; //&#123;name: &quot;Mike&quot;, age: 17&#125; Object.assign(target, source_1, ···) 浅拷贝用于将源对象的所有可枚举属性复制到目标对象中。 数组的处理1Object.assign([2,3], [5]); // [5,3] 会将数组处理成对象，所以先将 [2,3] 转为 {0:2,1:3} ，然后再进行属性复制，所以源对象的 0 号属性覆盖了目标对象的 0。 Object.is(value1,value2)用来比较两个值是否严格相等。与 (===) 基本相同 与 === 的区别12345// +0 != -0Object.is(+0, -0) // false// NaNObject.is(NaN,NaN); //trueNaN === NaN //false Generator可用通过关键字 yield 关键字，把函数的执行流挂起，为改变执行流提供了可能，从而为异步编程提供解决方案。函数的组成：有两个区分于普通函数的部分 一个是在function后面，函数名前面有个*；函数内部有 yield 表达式 其中 * 表示函数为 generator 函数， yield 用来定义函数内部的状态。 12345678function* func()&#123; console.log(&quot;one&quot;); yield &apos;1&apos;; console.log(&quot;two&quot;); yield &apos;2&apos;; console.log(&quot;three&quot;); return &apos;3&apos;;&#125; 调用方式 和普通函数一样，在函数名后面添加(), 但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象的iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。 123456789101112131415var f = func(); // 实例f.next();// one// &#123;value: &quot;1&quot;, done: false&#125; 返回值 f.next();// two// &#123;value: &quot;2&quot;, done: false&#125; f.next();// three// &#123;value: &quot;3&quot;, done: true&#125; f.next();// &#123;value: undefined, done: true&#125; 第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one ,执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。 第二次调用 next 方法时，同上步 。 第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。 第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。 函数返回的遍历器对象的方法 一般情况下，next 方法不传入参数的时候， yield 表达式的返回值是 undefined , 当 next 传入参数的时候，该参数作为上一步的 yield 的返回值。 12345678910111213141516171819202122232425262728293031323334function* sendParameter()&#123; console.log(&quot;strat&quot;); var x = yield &apos;2&apos;; console.log(&quot;one:&quot; + x); var y = yield &apos;3&apos;; console.log(&quot;two:&quot; + y); console.log(&quot;total:&quot; + (x + y));&#125;// next 不传参var sendp1 = sendParameter();sendp1.next();// strat// &#123;value: &quot;2&quot;, done: false&#125;sendp1.next();// one:undefined// &#123;value: &quot;3&quot;, done: false&#125;sendp1.next();// two:undefined// total:NaN// &#123;value: undefined, done: true&#125;// next传参var sendp2 = sendParameter();sendp2.next(10);// strat// &#123;value: &quot;2&quot;, done: false&#125;sendp2.next(20);// one:20// &#123;value: &quot;3&quot;, done: false&#125;sendp2.next(30);// two:30// total:50// &#123;value: undefined, done: true&#125; return 方法 return 方法返回给定值，并结束遍历 Generator 函数return 方法提供参数时，返回该参数，不提供该参数时，返回 undefined asyncasync 是ES7才有的语法1234567async function name([param[,param[,...param]]])&#123; statements&#125;// name 函数名称// param 要传递给函数的参数的名称// statements 函数体语句 async 返回一个 Promise 对象，可以使用 then 方法添加回调函数。1234567async function hello()&#123; return &quot;hello&quot;&#125;console.log(hello()) // Promisehello().then(v=&gt;&#123; console.log(v) // hello&#125;) async 函数中可能会有 await 表达式， async 函数执行时， 如果遇到 await 就会先暂停执行， 等触发的异步操作完成后， 恢复 async 函数的执行并返回解析值。 await 关键字只在 async function 中有效。 await 针对所跟不同表达式的处理方式 Promise 对象：await 会暂停执行，等待 Promise 对象 resolve, 然后恢复async函数的执行并返回解析值。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[date]]></title>
    <url>%2F2019%2F01%2F15%2Fvue-date%2F</url>
    <content type="text"><![CDATA[date.js 处理日期的函数 12345678910111213141516171819202122232425262728293031export function formatDate(date, fmt) &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)) &#125; const o = &#123; &apos;M+&apos;: date.getMonth() + 1, &apos;d+&apos;: date.getDate(), &apos;h+&apos;: date.getHours(), &apos;m+&apos;: date.getMinutes(), &apos;s+&apos;: date.getSeconds() &#125; for (const k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; const str = o[k] + &apos;&apos; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str) &#123; return (&apos;00&apos; + str).substr(str.length)&#125;// 用法// 可以使用filterdateFilter(number) &#123; // js默认是毫秒，先转换为毫秒 const date = new Date(number * 1e3) return formatDate(date, &apos;yyyy.MM.dd hh:mm:ss&apos;)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F01%2F15%2Fvue-router%2F</url>
    <content type="text"><![CDATA[vue-router的使用总结 传参普通模式（传单个值）123456789101112//《路由》/:id// 通过在路由后面添`/:id`,`id`是参数名称// 传参`:to=&quot;&apos;/user/&apos;+id&quot;`// 获取`$route.params.id`const User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;) 进阶模式使用props将组件和路由解耦 12345678910111213141516171819// User组件// 需要将id传入User组件// 作为User组件的属性直接使用const User = &#123; props: [&apos;id&apos;], template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &apos;/user/:id&apos;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 对象有的时候我们要传递一个对象到一个页面或者一个组件 123456789// 通过:to=&apos;/search?q=vue&amp;other=name&apos;将对象拆分传递// 可以看到vue-router已经将我们的参数编码了const router = new VueRouter(&#123; routes: [ // 我们可以通过props转换成需要的状态 // 在组件通过props获取 &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) 通过组件props获取的传参是不可修改的，可以在子组件新建变量接受参数。12345data()&#123; return &#123; currentQ:this.q &#125;&#125; 然后就可以对他进行修改了。猜测是const类型 todo:了解原理 嵌套路由使用场景，只更改部分页面时使用嵌套路由]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2019%2F01%2F11%2Fnginx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2019%2F01%2F10%2Fcss%2F</url>
    <content type="text"><![CDATA[用于记录css遇到的问题 button123456typebutton的类型。可选值：* submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。* reset: 此按钮重置所有组件为初始值。* button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。* menu: 此按钮打开一个由指定&lt;menu&gt;元素进行定义的弹出菜单。 注：默认为submit可以出发输入框回车事件。 text-overflowrunoob语法 123属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（&apos;...&apos;，U + 2026 HORIZONTAL ELLIPSIS）或显示一个自定义字符串。这个属性并不会强制&quot;溢出&quot;事件的发生，因此为了能让&quot;text-overflow&quot;能够生效，程序员们必须要在元素上添加几个额外的属性，比如&quot;将overflow 设置为hidden&quot;。 省略号123456789101112131415&#123; -webkit-text-overflow: ellipsis; text-overflow: ellipsis; overflow: hidden;&#125;单行省略&#123; white-space: nowrap; // 不换行 width: 10rem; -webkit-text-overflow: ellipsis; text-overflow: ellipsis; overflow: hidden;&#125;注：需要适配浏览器 图片自适应一般是控制宽度高度自适应 用代码翻译一下就是12max-width: 100%;height: auto; display12345默认 inline // 元素会被显示为内联元素，元素前后没有换行符。block // 元素被显示为块级元素，元素前后有换行符none // 元素不显示，也不占空间inherit // 元素继承父元素的属性inline-block // 行内块元素 word-break12345指定了在单词内断行normal // 使用默认的断行规则break-all // 可在任意字符间断行keep-all // 文本不断行break-word // 断行，但是不会断单个单词 box-sizingbox-sizing content-box：就是默认使用的盒模型，content只包括盒模型的width和heightborder-box：content包括content/padding/border css3新特性用于那些属性需要添加前缀-can i use 圆角12345678910111213141516171819div&#123; border:2px solid; border-radius: 25px;&#125;div&#123; border-top-left-radius: 50%;&#125;.radius&#123; width: 200px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ border-radius: 100px 100px 50px 20px; // top left 左上角开始顺时针旋转 border-radius: 100px 50px; //分别代表斜对角的radius值 border-top-left-radius: 100px 50px; // 分别代表椭圆的x(横)和y(纵)当两者相等时画出的是圆角 &#125;注 50%是画圆 半圆123456789.radius&#123; width: 100px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ /* border-radius: 100px 50px; */ border-radius: 100px 0 0 100px; &#125; 伪类选择器列表 12345678a:linka:visited // 链接点击过之后的颜色a:hover // 鼠标在元素上的颜色a:active // 鼠标左键长按的颜色状态伪类选择器input:enabledinput:disabled 隔行换色123456789101112131415161718语法:nth-child(2) //选择第二个:nth-child(2n) //选择所有偶数行:nth-child(2n+1) //选择所有基数行:nth-child(n+5) //选择从第五行开始:nth-child(n) //全选:nth-last-child() // 和上面相同，从最后一个子元素开始算// 上面计数时包括当前标签里的所有类型的元素都会计数// 所以都是相同元素的时候没有影响:nth-of-type() // 从当前限定的元素类型开始计算，用法同上:nth-last-of-type():first-of-type():last-of-type():only-child() // 当前只有一个子元素时:only-of-type() // 当前只有一个子元素并且是当前限定的元素类型 伪元素mdn伪类和伪元素 123456789语法：跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 `::` ， 同样是添加到选择器后面去选择某个元素的某个部分。::after::before::first-letter::first-line::selection::backdrop 示例12345678910111213&lt;style&gt;.letter::first-letter&#123; font-size: 35px; color: crimson; font-weight: bold; float: left;&#125;/* 添加float:left首个文字就会下沉 */.letter::first-line&#123; color: #f66&#125;/* 首行 */&lt;/style&gt; 1234::after&#123; content:url();&#125;::before // 这两个元素在使用时必须有content 画对话框123456789101112131415161718.dialog&#123; width: 200px; height: 50px; line-height: 50px; background-color: #f66; border-radius: 6px; position: relative; &#125; .dialog::before&#123; content: &apos;&apos;; border-width: 10px; border-color: transparent; border-style: solid; border-right: 10px solid #f66; position: absolute; top: 15px; left: -20px; &#125; 画菱形和平行四边形要考虑样式的兼容性。12345678910111213141516171819202122画菱形的思路：先画个正方形旋转45度。 单位deg .diamond&#123; width: 200px; height: 200px; -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); background-color: aqua; &#125;平行四边形使用倾斜.parallel&#123; width: 300px; height: 200px; -ms-transform: skewX(45deg); -moz-transform: skewX(45deg); -webkit-transform: skewX(45deg); -o-transform: skewX(45deg); transform: skewX(45deg); background-color: aqua; &#125; 五角星和六角星发光字体、立体字runoob 123456text-shadow: h-shadow v-shadow blur color;h-shadow 必需。水平阴影的位置。允许负值。v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。参阅 CSS 颜色值。 rem设置基准然后根据基准计算。123html&#123; font-size:62.5%; // 10/16*100% 默认16px&#125; flex参考Flexible Box的缩写，意思是弹性布局 123display: flex;// 行内元素也可以display: inline-flex; flex-direction 主轴的方向,项目的排列方向123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap 轴线上如何换行123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; flex-flow 是flex-direction和flex-wrap的简写形式123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-content 主轴的对其方式12345.box &#123; justify-content: flex-start(默认值) | flex-end | center | space-between | space-around;&#125;// space-between 项目之间的距离都相等// space-around 项目两侧的间隔都相等，所以项目之间的间隔比与边框的间隔大一倍 align-items 交叉轴上如何对齐12345.box &#123; align-items: flex-start | flex-end | center | baseline | stretch(默认值));&#125;// baseline 项目的第一行文字的基线对齐// stretch 如果项目未设置高度或设为auto，将占满整个容器的高度。 align-conetent align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用项目的属性order项目的顺序，数字越小，排列越靠前，默认值是0 flex-grow定义项目的放大的比例，默认为0，保持自身，即使还有剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2019%2F01%2F03%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp使用记录并形成自己的一套插件 复制文件]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm]]></title>
    <url>%2F2019%2F01%2F03%2Fnpm%2F</url>
    <content type="text"><![CDATA[世界上最大的软件注册表(做JavaScript的都要懂得) npm由三个部分组成 网站 注册表（registry） 命令行工具（CLI）]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 基础]]></title>
    <url>%2F2018%2F12%2F26%2Fjs-base%2F</url>
    <content type="text"><![CDATA[基础 原始类型原始类型是那几种？null是对象吗？ 6种 number string boolean null undefined symbol 我的理解： number 9527 string ‘9527’,”9527” boolean true,false Null null undefined symbol （ECMAScript 6新定义） 首先，原始类型存储的都是值，是没有函数可以调用的。 12undefined.toString()null.toString() 会报Cannot read property &#39;toString&#39; of null这个错误。此时你肯定会有意外，比如下面这种情况为什么这时候的&#39;1&#39;是可以调用这么多函数的？其实在这种情况下，&#39;1&#39;已经不是原始类型了，而是被强制转换成了String类型，也就是对象类型，所以可以调用toString函数。 除了会在必要的情况下强制转换类型以外，原始类型还有一些坑。 number类型是浮点类型的，在使用的过程中会遇到某些bug，比如0.1+0.2!=0.3。string类型是不可变的，无论你在string类型上调用任何方法，都不会对值有改变。除 Object 以外的所有类型都是不可变的，这里是值本身无法被改变。JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变，然后这些类型的值被称为”原始值”。null有的人会认为他是object,其实这是历史遗留问题。虽然typeof null会输出object。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 拓展： 最新的 ECMAScript 标准定义了 7 种数据类型:包括以上6种类型和object。 对象类型对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ js中除了原始类型之外的其他的都是原始类型。不同：原始类型存储的是值，对象类型存储的是地址。函数参数是对象会发生，函数中修改了参数值，对象的值也跟着改变。 小题：12345678910111213141516function test(person) &#123; person.age = 26 person = &#123; name: &apos;yyy&apos;, age: 30 &#125; return person&#125;const p1 = &#123; name: &apos;yck&apos;, age: 25&#125;const p2 = test(p1)console.log(p1) // -&gt; ?console.log(p2) // -&gt; ? 通过字面量创建的是一个新对象。 在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。 typeof vs instanceofmdn原型链 语法：1234567typeof operandoperand:对象或者原始值instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置object instanceof constructorobject: 要检测的对象 // 必须是对象呢constructor: 某个构造函数 instanceof 典型的用法是判断是否继承关系，用于测试对象是不是特定构造函数的实例。 实现instanceof要点： obj 是null 或者不是对象的时候返回 false 每个实例对象都有一个私有属性( proto )指向它的原型对象Prototype 该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。123456789101112131415161718function myinstanceof(obj, constructor)&#123; if(obj === null || typeof obj !== &apos;Object&apos;)&#123; // 去除Null和不是对象的情况 return false &#125; // 获得构造函数的原型对象 const prototype = constructor.prototype // 获取对象的原型 let _proto = obj.__proto__ // 推荐使用 Object.getPrototypeOf(object) while(true)&#123; if(_proto === null)&#123; // 最后一个环节 return false &#125; if(_proto === prototype)&#123; return true &#125; _proto = obj.__proto__ &#125;&#125; Object.getPrototypeOf(object)在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，参数会被强制转换为一个 Object。 类型转换在js中类型转换只有三种情况。 转换成boolean 转换成string 转换成number 转换成boolean this 在绝大多数情况下，函数的调用方式决定了this的值。this不能再执行期间被赋值，并且在函数每次函数被调用时this的值可能不会相同。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行环境内设置this的值）。 全局环境 无论是否在严格模式下，在全局执行环境中this指向全局函数。 在严格模式下，this将保持他执行环境的值。如果this没有被环境定义，那他将保持为undefined。 12345678910function f1()&#123; return this;&#125;f1(); // windowfunction f2()&#123; &apos;use strict&apos;; return this;&#125;f2(); // undefined 因为f2是被直接调用的，而不是作为对象的属性或方法调用的。 如果想把this的值从一个环境传到另一个环境，就需要使用call或者apply。 12345678var obj = &#123;a:&apos;custom&apos;&#125;;var a = &apos;global&apos;;function whatsThis(arg)&#123; return this.a;&#125;whatsThis(); // &apos;global&apos;whatsThis.call(obj); // &apos;custom&apos;whatsThis.apply(obj); // &apos;custom&apos; 当一个函数在其主体中使用this关键字时，可以通过使用函数继承自function.prototype的call或apply方法将this绑定到调用中的特定对象。也就是调用call或apply方法绑定到调用的对象上。123456789101112131415function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用// call(obj,...arguments)add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数// apply(obj,[...arguments])add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 注：使用call和apply时，如果传递给this的不是一个对象，javascript会使用相关构造函数将其转换为对象。 es5引入了function.prototype.bind。调用f.bind(someObject)会创建一个和f具有相同函数体和作用域的函数，但是在这个新函数中，this被永久性的绑定到了bind第一个参数上。 123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&apos;yoo&apos;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty es6箭头函数：this与封闭词法环境中的this保持一致。全局代码中是window。 当代码被内联on-event函数调用时，this指向监听器当前所在的dom。注意: 只有最外层的this是这样设置的。12345678910&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; Show this&lt;/button&gt;// dom&lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt; Show inner this&lt;/button&gt;// 等同于alert((function()&#123;return this&#125;)()); // windowalert((function()&#123;&apos;use strict&apos;; return this&#125;)()); // undefined 参见this详解 == 和 === 的区别问题：[]==![]的结果是什么，[]==[]呢? 参见比较运算符详解 JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。 字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。 比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后得到被四舍五入后的数字类型的值。如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。如果一个对象与数字或字符串相比较，JavaScript会尝试返回对象的默认值。操作符会尝试通过方法valueOf和toString将对象转换为其原始值（一个字符串或数字类型的值）。如果尝试转换失败，会产生一个运行时错误。注意：当且仅当与原始值比较时，对象会被转换为原始值。当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true。 类型转换 深浅拷贝assign详解 概念深拷贝：对象类型赋值时新建一个对象，分配了内存，指向不同的对象互不干扰浅拷贝：对象类型赋值时复制了地址，指向同一个对象，改了一个另外一个也发生改变 浅拷贝通过Object.assign实现1针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。 语法Object.assign(target, …sources)参数target目标对象。sources源对象。 返回值目标对象。 深拷贝通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。参考但是也有局限性 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 推荐使用lodash的深拷贝函数 构造函数如果函数用来初始化(使用new运算符)一个新建的对象，称之为构造函数创建对象的两种方法：字面量方法和构造函数 123456function createPerson(name)&#123; this.name = name; this.greeting = function()&#123; alert(&apos;Hi! I&apos;m &apos;+name+&apos;.&apos;); &#125;&#125; 当你输入网址的时候发生了什么答案在这 http2比http1快了多少here 123456789101112优化了哪些？http1请求是队头阻塞的,http2复用同一个tcp链接http2引入了新的编码机制，并采用二进制传输http2通过引入`帧`和`流`的方式实现多路复用http2对header进行了压缩新的问题原因：使用的tcp，如果出现丢包的情况，该条线路就会进入阻塞状态，等待重传。http3采用QUIC QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议 绝对路径与相对路径1234相对路径./ 当前目录../ 父级目录/ 当前项目的根目录 location属性123location.search //返回`?`以及`?`以后的部分location.hash // 返回一个URL的锚部分location.host // 返回一个URL的主机名 判断一个对象是否有值1Object.keys(obj).length // es6 Number 和 0奇怪的用法12345678// 转义function htmlEncodeJQ ( str ) &#123; return $(&apos;&lt;span/&gt;&apos;).text( str ).html();&#125;// 解码function htmlDecodeJQ ( str ) &#123; return $(&apos;&lt;span/&gt;&apos;).html( str ).text();&#125; 防抖和节流1234567const debounce = (func, wait = 50)=&gt;&#123; let timer,args return function(...args)&#123; if(timer) clearTimeout(timer); timer = setTimeout(()=&gt;&#123;func.apply(this, args)&#125;, wait) &#125;&#125; 这是一个简单的防抖函数，只能在延时函数执行时执行动作。如果想立即执行动作，需要添加immediate选项用于表示是否立即执行。并且在执行时间间隔不会执行下一个动作。1234567891011const debounce = (func, wait = 50, immediate=true)=&gt;&#123; let timer,args return function(...args)&#123; if(timer) clearTimeout(timer); timer = setTimeout(()=&gt;&#123;func.apply(this, args)&#125;, wait) if(immediate)&#123; func.apply(this, args) clearTimeout(timer) &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;boolean&#125; immediate 设置为ture时，是否立即调用函数 * @return &#123;function&#125; 返回客户调用函数 */function debounce (func, wait = 50, immediate = true) &#123; let timer, context, args // 延迟执行函数 const later = () =&gt; setTimeout(() =&gt; &#123; // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) &#123; func.apply(context, args) context = args = null &#125; &#125;, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) &#123; // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) &#123; timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) &#123; func.apply(this, params) &#125; else &#123; context = this args = params &#125; // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 &#125; else &#123; clearTimeout(timer) timer = later() &#125; &#125;&#125; 节流：多次执行优化成没隔一段时间执行一次1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param &#123;function&#125; func 回调函数 * @param &#123;number&#125; wait 表示时间窗口的间隔 * @param &#123;object&#125; options 如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。 * 如果想忽略结尾函数的调用，传入&#123;trailing: false&#125; * 两者不能共存，否则函数不能执行 * @return &#123;function&#125; 返回客户调用函数 */_.throttle = function(func, wait, options) &#123; var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = &#123;&#125;; // 定时器回调函数 var later = function() &#123; // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; &#125;; return function() &#123; // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous &amp;&amp; options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining &lt;= 0 || remaining &gt; wait) &#123; // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; previous = now; result = func.apply(context, args); if (!timeout) context = args = null; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); &#125; return result; &#125;; &#125;; JavaScript标准库decodeURI() 解码inEvent loopjavaScript 的并发模型基于“事件循环”。 在了解执行栈之前先来了解一些概念 运行时概念( runtime concepts)如图 栈(stack)先进后出 堆(heap)对象被分配在一个堆中，是一个用于表示一大块非结构化的内存区域 队列什么事执行栈(调用栈)？执行栈，就是代码执行期间调用函数形成的调用栈。是引擎在追踪函数执行流的一种机制。当执行环境中调用了多个函数时，我们能够追踪到哪个函数正在执行，执行的函数又调用了哪个函数。 todo 什么时间创建栈？个数限制？ 答：javaScript 是一门单线程的语言，这意味着它只有一个调用栈。 单个栈的数量是有限制的12345function func() &#123; func()&#125;func()//Maximum call stack size exceeded 调用栈[译] JavaScript 如何工作：对引擎、运行时、调用堆栈的概述 当脚本要执行一个函数时，引擎把该函数添加到栈中并执行 任何被这个函数调用的函数会进一步添加到调用栈中，并且会运行到他们被上个程序调用的位置 当函数运行结束后，引擎将他从调用栈中取出，并在主代码列表中继续执行代码 如果栈调用的空间比分配给它的内存空间大，则会导致”栈溢出” Event Loop 中异步代码的执行顺序？ Event Loop 是什么？上面说到什么是执行栈，也就是说 javaScript 引擎在执行代码的时候，遇到函数会将函数压入执行栈，函数执行完弹出栈。 但是遇到异步代码怎么办？ 异步代码会被挂起，并在需要执行的时候放到队列中，宏任务放到宏任务队列队尾，微任务放到微任务队列队尾，当当前执行栈为空时，从队列中获取需要执行的代码并执行。本质上异步还是同步。 异步函数被分为 宏任务 和 微任务 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。 微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。 Event Loop 的执行顺序 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） 事件循环模型的特性，永不阻塞 总结：JavaScript异步、事件循环与消息队列、微任务与宏任务]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原始类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程师必须懂得概念（一）]]></title>
    <url>%2F2018%2F12%2F20%2Fjs-call-stack%2F</url>
    <content type="text"><![CDATA[调用堆栈 调用栈是解析器的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数在执行，什么函数被这个函数调用，下一个调用的函数是谁。） 当脚本要执行一个函数时，解析器把该函数添加到栈中并执行 任何被这个函数调用的函数会进一步添加到调用栈中，并且会运行到他们被上个程序调用的位置 当函数运行结束后，解释器将他从调用栈中取出，并在主代码列表中继续执行代码 如果栈调用的空间比分配给它的内存空间大，则会导致”栈溢出”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>call stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的事件注册机制]]></title>
    <url>%2F2018%2F12%2F20%2Fbrowser-event%2F</url>
    <content type="text"><![CDATA[记录学习浏览器的事件机制 事件触发的三个阶段 window向事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处触发注册的事件 从事件触发处向window传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 1234567// 以下会先打印冒泡然后是捕获node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;冒泡&apos;)&#125;,false);node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;捕获 &apos;)&#125;,true) 那么我们怎么区分注册的事件是冒泡事件还是捕获事件？ 我们通常使用addEventListener注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture，布尔值，和 useCapture 作用一样 once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 12345678node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; event.stopImmediatePropagation() console.log(&apos;冒泡&apos;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&apos;click&apos;,(event) =&gt; &#123; console.log(&apos;捕获 &apos;)&#125;,true) stopPropagation只能阻止事件的进一步传播，默认注册的事件还是会执行。和他相反的是preventDefault方法，用于阻止默认事件的执行，但是会发送事件的进一步传播，通常是对注册事件重新定义时使用。return false;就等于同时调用了event.stopPropagation()和event.preventDefault()，即会阻止事件冒泡也会阻止默认事件。 事件代理如果一个节点中的子节点是动态生成的话，那么子节点的事件应该注册在符节点上 优点： // 为什么这么做节省内存提高性能不需要给子节点注册事件和注销事件 跨域跨域是浏览器自我保护的一个机制：同源策略。提高安全性，用于防止CSRF攻击。CSRF简单讲就是获取用户的登录状态，通过登录状态获取用户信息或者修改信息。 解决方法： JSONP 利用标签没有跨域限制，通过src属性指向一个地址并提供回调函数来接收数据。缺点： 仅适用于get请求 CORS 服务端设置Access-Control-Allow-Origin。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有资源都可以访问资源。 document.domain可以设置一级域名，表示该泛域名下的二级域名都可以访问 postMessage 用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。 (ToDo理解)12345678910// 发送消息端window.parent.postMessage(&apos;message&apos;, &apos;http://test.com&apos;)// 接收消息端var mc = new MessageChannel()mc.addEventListener(&apos;message&apos;, event =&gt; &#123; var origin = event.origin || event.originalEvent.origin if (origin === &apos;http://test.com&apos;) &#123; console.log(&apos;验证通过&apos;) &#125;&#125;) localStorage (ToDo实现失效日期)传入一个字符串，将对象转换成json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Storage&#123; constructor(name)&#123; this.name = &apos;storage&apos;; &#125; //设置缓存 setItem(params)&#123; let obj = &#123; name:&apos;&apos;, value:&apos;&apos;, expires:&quot;&quot;, startTime:new Date().getTime()//记录何时将值存入缓存，毫秒级 &#125; let options = &#123;&#125;; //将obj和传进来的params合并 Object.assign(options,obj,params); if(options.expires)&#123; //如果options.expires设置了的话 //以options.name为key，options为值放进去 localStorage.setItem(options.name,JSON.stringify(options)); &#125;else&#123; //如果options.expires没有设置，就判断一下value的类型 let type = Object.prototype.toString.call(options.value); //如果value是对象或者数组对象的类型，就先用JSON.stringify转一下，再存进去 if(Object.prototype.toString.call(options.value) == &apos;[object Object]&apos;)&#123; options.value = JSON.stringify(options.value); &#125; if(Object.prototype.toString.call(options.value) == &apos;[object Array]&apos;)&#123; options.value = JSON.stringify(options.value); &#125; localStorage.setItem(options.name,options.value); &#125; &#125; //拿到缓存 getItem(name)&#123; let item = localStorage.getItem(name); //先将拿到的试着进行json转为对象的形式 try&#123; item = JSON.parse(item); &#125;catch(error)&#123; //如果不行就不是json的字符串，就直接返回 item = item; &#125; //如果有startTime的值，说明设置了失效时间 if(item.startTime)&#123; let date = new Date().getTime(); //何时将值取出减去刚存入的时间，与item.expires比较，如果大于就是过期了，如果小于或等于就还没过期 if(date - item.startTime &gt; item.expires)&#123; //缓存过期，清除缓存，返回false localStorage.removeItem(name); return false; &#125;else&#123; //缓存未过期，返回值 return item.value; &#125; &#125;else&#123; //如果没有设置失效时间，直接返回值 return item; &#125; &#125; //移出缓存 removeItem(name)&#123; localStorage.removeItem(name); &#125; //移出全部缓存 clear()&#123; localStorage.clear(); &#125; &#125;]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>browser event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-bibao%2F</url>
    <content type="text"><![CDATA[闭包 函数A返回了函数B,并且函数B使用了函数A的变量，函数B就成为闭包。 1234567function A()&#123; let a = 1; function B()&#123; console.log(a); &#125; return B();&#125; 为什么函数A已经调用出栈了，为什么函数B还能引用到函数A中的变量。是否和我有相同的疑问？因为函数A中的变量这时候是存储在堆上的，现在的js引擎可以通过逃逸分析辨别出那些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2018%2F12%2F17%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[promise是ES6新增的语法，解决了回调地狱的问题。 可以吧Promise看成一个状态机。初始是 pending(挂起) 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 三种状态const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;// promise 接收一个函数参数，该函数会立即执行function MyPromise(fn) &#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) &#125; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125;; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125; // 用于解决以下问题 // new Promise(() =&gt; throw Error(&apos;error)) try &#123; fn(_this.resolve, _this.reject); &#125; catch (e) &#123; _this.reject(e); &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123; var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) =&gt; console.log(value)) onResolved = typeof onResolved === &apos;function&apos; ? onResolved : v =&gt; v; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; throw r; if (self.currentState === RESOLVED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () &#123; try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function () &#123; // 考虑到可能会有报错，所以使用 try/catch 包裹 try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); self.rejectedCallbacks.push(function () &#123; try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123; // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) &#123; return reject(new TypeError(&quot;Error&quot;)); &#125; // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; // 规范 2.3.3.2，如果不能取出 then，就 reject try &#123; // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === &quot;function&quot;) &#123; // 规范 2.3.3.3 then.call( x, y =&gt; &#123; if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ); &#125; else &#123; // 规范 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 规范 2.3.4，x 为基本类型 resolve(x); &#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用栈实现队列]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-quene%2F</url>
    <content type="text"><![CDATA[先上代码 1234567891011121314151617181920212223function Quene() &#123; var stack1 = [], stack2 = [] this.push = function(node) &#123; stack1.push(node) &#125; this.pop = function() &#123; if (stack2.length == 0) &#123; if (stack1.length == 0) &#123; return null &#125; else &#123; var len = stack1.length for (var i = 0; i &lt; len; i++) &#123; stack2.push(stack1.pop()) &#125; return stack2.pop() &#125; &#125; else &#123; return stack2.pop() &#125; &#125;&#125; 栈有入栈和出栈，实现队列就是将两个栈，通过栈顶和另一个的栈底相连，然后一个栈一直执行入栈，另一个一直执行出栈就可以了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>quene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js实现单例模式]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-single%2F</url>
    <content type="text"><![CDATA[先上代码：惰性单例的精髓！！！ 123456789//单例模式抽象，分离创建对象的函数和判断对象是否已经创建// func 构造函数// arguments 参数var getSingle = function(func,arguments)&#123; var result; return function(arguments)&#123; return result || (result = func.apply(this, arguments)); &#125;&#125; 形参fn是我们的构造函数，我们只要传入任何自己需要的构造函数，就能生成一个新的惰性单例。比如说传入创建一个女朋友的构造函数，并且调用getSingle(),就能生成一个新的女朋友。如果以后再调getSingle(),也只会返回刚才创建的那个女朋友。至于新女朋友——不存在的。]]></content>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F11%2Fcss%2Ftest%2F</url>
    <content type="text"><![CDATA[Document .triangle { height: 0; width: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } .box { width: 0px; height: 0px; margin: 10px; border-left: 100px solid red; border-right: 100px solid blue; border-top: 100px solid yellow; border-bottom: 100px solid green; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[用css画三角形]]></title>
    <url>%2F2018%2F12%2F11%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[1234567.triangle&#123; height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red;&#125; 画出的是一个倒立的三角形, 改为border-bottom就是一个正立的三角形。其中是底边为100px,高度为100px的等腰三角形。 border画多边形的原理123456789.box&#123; width: 100px; height: 100px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125; 盒子模型 如上图的盒子模型，可以明显的看出，border实际上是一个等腰梯形。 当宽度为0时 宽度为0 四个边框变成四个等腰三角形。 TODO：继续深入了解，解决梯形的问题 当width和height为0时，默认是四个三角形，当宽度或高度不为0的时候，就可以画出梯形。 123456789.box&#123; width: 100px; height: 0; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中一般怎么实现继承]]></title>
    <url>%2F2018%2F12%2F10%2Fjs-super%2F</url>
    <content type="text"><![CDATA[学习一下js的继承实现。 123456789101112131415161718192021222324function Animal(name)&#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &quot; 正在睡觉。&quot;); &#125;&#125; // 原型方法 Animal.prototype.eat = function(food)&#123; console.log(this.name + &quot; 正在吃 &quot;+food);&#125;// 子类function Tiger()&#123;&#125;Tiger.prototype = new Animal();Tiger.prototype.name = &quot;Tiger&quot;;var tiger = new Tiger();console.log(tiger.name);console.log(tiger.eat(&apos;sleep&apos;));console.log(tiger.sleep());console.log(tiger instanceof Animal); //true console.log(tiger instanceof Tiger); //true 效果原型链 ##特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 ##缺点： 可以在子类构造函数中，为子类实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 TODO：写这个的时候还是有点蒙。 组合继承同上Object.create实现继承1234567891011function parent(val)&#123; this.x = val;&#125;function child(val)&#123; parent.call(this,val); this.y = val;&#125;child.prototype = Object.create(parent.prototype);child.prototype.constructor = child;const child = new child(1);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中$的实现方式]]></title>
    <url>%2F2018%2F12%2F10%2Fjquery%2F</url>
    <content type="text"><![CDATA[实现方式(网上找的)123456789101112131415161718192021&lt;script&gt; (function(w)&#123; //工厂 function jQuery(selector, context)&#123; return new jQuery.fn.init(selector, context); &#125; //给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; &#125;; //init才是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector, context)&#123; // 构造函数 &#125;; //把构造函数的原型，替换为jQuery工厂的原型 //这么做的目的是为了实现jQuery的插件机制，让外界可以通过jQuery方便的进行扩展 init.prototype = jQuery.fn; w.jQuery = w.$ = jQuery; &#125;(window));&lt;/script&gt; 原链接 1234(function(w)&#123; // dosomthing w.jQuery = w.$ = jQuery; &#125;)(window) 目的：通过全局对象window可以调用对象jQuery或者$ 然后我们声明一个对象jQuery1234(function(w)&#123; function jQuery(selector, context)&#123;&#125; w.jQuery = w.$ = jQuery;&#125;)(window) 效果: 大功告成！但是jQuery显然是更深一层次的做法。示例方式是将原型转换为简化方法fn。然后在jQuery原型上添加一个init方法。 工厂模式什么是工厂模式？怎么在javascript使用？ 工厂模式是用来创建对象的一种最常见的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装到一个函数中，如示例中的jQuery函数，那么这个函数就可以被视为一个工厂。 工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 工厂模式 toggle 切换显示/隐藏mdn类似的例子]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapp登录注册时的密码处理思考]]></title>
    <url>%2F2018%2F12%2F07%2Fwebsign%2F</url>
    <content type="text"><![CDATA[webapp在登录的时候怎么控制登录的安全性？ 目前通过https都可以解决这个问题。使用https自动加密传输的数据，从而解决传输密码明文的问题。然后在存储到数据库前通过md5或者其他加密算法进行加密。 #加盐 不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。通常需要对密码加盐，然后进行几次不同加密算法的加密。12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 摘自：interviewmap 不采用http的才使用前端加密后端解密的方式。 题外话：不加https的网站我不用，没有安全锁标志的不用!!! ╭(╯^╰)╮]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualbox-centos7.5-wdcp]]></title>
    <url>%2F2018%2F12%2F04%2Fvirtual-cenos7-5%2F</url>
    <content type="text"><![CDATA[用于记录一次成功使用virtualbox虚拟机安装centos7.5成功联网并安装上wdcp 虚拟机软件当然选免费的了，而且发现好多VMware Workstation的软件链接提示有病毒，qnmlgb老子不用。 centos下载centos7.5-dvd版 要点要点1:虚拟机网卡设置要点2:虚拟机打开网络注：centos默认不启动网卡，需要手动启动路径：123cd /etc/sysconfig/network-scripts/vi ifcfg-xx 找到开头为ifcfg-的，默认是en0输入i进入编辑模式编辑该文件设置ONBOOT=yes:wq 保存退出重启网络1service network restart 有时候要重启虚拟机才能生效。]]></content>
      <categories>
        <category>virtualbox</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[记录markdown的使用方法 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体* 加粗**[要加粗的文字]**用两个*号包起来 斜体*[要斜体的文字]*用一个*号包起来_[要斜体的文字]_用一个_号包起来 斜体加粗***[要斜体加粗的文字]***用三个号包起来**_[要斜体加粗的文字]_**用三个号包起来 删除线~~[要删除线的文字]~~用两个~号包起来 示例：123456**这是加粗的文字***这是倾斜的文字*_这是倾斜的文字_***这是斜体加粗的文字*****_这是斜体加粗的文字_**~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字这是倾斜的文字这是斜体加粗的文字这是斜体加粗的文字这是加删除线的文字 注:加粗hexo不能用 捂脸 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 _。行内不能有其他东西，也可在号中间插入空格。 示例:1234-------******** 效果如下： 注：效果一样 o(￣︶￣)o，hexo 三个-没用 ￣□￣｜｜ 图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：1![小猪佩奇](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1543491437191&amp;di=d1111fbe37d3bd83c8121132d6117c4f&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20180802%2F01%2F1533145434-yGPirmnoVd.jpg &apos;&apos;小猪&apos;&apos;) 效果如下： 超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：1[百度](https://baidu.com &quot;@百度&quot;) 百度 注：Markdown本身语法不支持链接在新页面中打开,如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 列表无序列表使用* - + 作为列表标记注:标记和内容之间要加空格 示例:1234567891011* red* green* yellow- red- green- yellow+ red+ green+ yellow 效果如下: red green yellow red green yellow red green yellow 有序列表使用数字接着一个英文句号注:标记和内容之间要加空格 示例：1233. red2. green1. yellow red green yellow 注:有序的起始数只和第一个有关 表格语法：123456表头|表头|表头|表头---|:--:|---:|:--内容|居中|居右|居左内容|居中|居右|居左-有一个就行 效果如下：表头|表头|表头|表头—|:–:|—:|:–内容|居中|居右|居左内容|居中|居右|居左 注：很显然 hexo并没有用 下划线语法：1&lt;u&gt;123&lt;/u&gt; 效果如下：123注：使用的是html标签 颜色、字体、字体大小语法：12345678910111213&lt;font color=#ee0000 size=9 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=8 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=7 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=6 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=5 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=4 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=3 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=2 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=1 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;color 16进制颜色size 6-1分别对应h1-h6共6个级别face 字体 效果如下： 我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑 代码语法：1234567单行代码`代码内容`多行代码块(```) 代码块(```) 效果如下 单行代码代码内容 多行代码块1代码块 流程图示例：123456789flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果如下flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 注：hexo 不支持]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
