<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-bibao%2F</url>
    <content type="text"><![CDATA[闭包 函数A返回了函数B,并且函数B使用了函数A的变量，函数B就成为闭包。 1234567function A()&#123; let a = 1; function B()&#123; console.log(a); &#125; return B();&#125; 为什么函数A已经调用出栈了，为什么函数B还能引用到函数A中的变量。是否和我有相同的疑问？因为函数A中的变量这时候是存储在堆上的，现在的js引擎可以通过逃逸分析辨别出那些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题：]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2018%2F12%2F17%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[promise是ES6新增的语法，解决了回调地狱的问题。 可以吧Promise看成一个状态机。初始是 pending(挂起) 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 三种状态const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;// promise 接收一个函数参数，该函数会立即执行function MyPromise(fn) &#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) &#125; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125;; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125; // 用于解决以下问题 // new Promise(() =&gt; throw Error(&apos;error)) try &#123; fn(_this.resolve, _this.reject); &#125; catch (e) &#123; _this.reject(e); &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123; var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) =&gt; console.log(value)) onResolved = typeof onResolved === &apos;function&apos; ? onResolved : v =&gt; v; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; throw r; if (self.currentState === RESOLVED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () &#123; try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function () &#123; // 考虑到可能会有报错，所以使用 try/catch 包裹 try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); self.rejectedCallbacks.push(function () &#123; try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123; // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) &#123; return reject(new TypeError(&quot;Error&quot;)); &#125; // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; // 规范 2.3.3.2，如果不能取出 then，就 reject try &#123; // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === &quot;function&quot;) &#123; // 规范 2.3.3.3 then.call( x, y =&gt; &#123; if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ); &#125; else &#123; // 规范 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 规范 2.3.4，x 为基本类型 resolve(x); &#125;&#125;]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用栈实现队列]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-quene%2F</url>
    <content type="text"><![CDATA[先上代码 1234567891011121314151617181920212223function Quene() &#123; var stack1 = [], stack2 = [] this.push = function(node) &#123; stack1.push(node) &#125; this.pop = function() &#123; if (stack2.length == 0) &#123; if (stack1.length == 0) &#123; return null &#125; else &#123; var len = stack1.length for (var i = 0; i &lt; len; i++) &#123; stack2.push(stack1.pop()) &#125; return stack2.pop() &#125; &#125; else &#123; return stack2.pop() &#125; &#125;&#125; 栈有入栈和出栈，实现队列就是将两个栈，通过栈顶和另一个的栈底相连，然后一个栈一直执行入栈，另一个一直执行出栈就可以了。]]></content>
      <tags>
        <tag>quene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js实现单例模式]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-single%2F</url>
    <content type="text"><![CDATA[先上代码：惰性单例的精髓！！！ 1234567//单例模式抽象，分离创建对象的函数和判断对象是否已经创建var getSingle = function(fn)&#123; var result; return function()&#123; return result || (result = fn.apply(this, arguments)); &#125;&#125; 形参fn是我们的构造函数，我们只要传入任何自己需要的构造函数，就能生成一个新的惰性单例。比如说传入创建一个女朋友的构造函数，并且调用getSingle(),就能生成一个新的女朋友。如果以后再调getSingle(),也只会返回刚才创建的那个女朋友。至于新女朋友——不存在的。]]></content>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[Document .triangle{ height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } .box{ width: 0px; height: 0px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[用css画三角形]]></title>
    <url>%2F2018%2F12%2F11%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[1234567.triangle&#123; height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red;&#125; 画出的是一个倒立的三角形, 改为border-bottom就是一个正立的三角形。其中是底边为100px,高度为100px的等腰三角形。 border画多边形的原理123456789.box&#123; width: 100px; height: 100px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125; 盒子模型 如上图的盒子模型，可以明显的看出，border实际上是一个等腰梯形。 当宽度为0时 宽度为0 四个边框变成四个等腰三角形。 TODO：继续深入了解，解决梯形的问题 当width和height为0时，默认是四个三角形，当宽度或高度不为0的时候，就可以画出梯形。 123456789.box&#123; width: 100px; height: 0; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中一般怎么实现继承]]></title>
    <url>%2F2018%2F12%2F10%2Fjs-super%2F</url>
    <content type="text"><![CDATA[学习一下js的继承实现。 123456789101112131415161718192021222324function Animal(name)&#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &quot; 正在睡觉。&quot;); &#125;&#125; // 原型方法 Animal.prototype.eat = function(food)&#123; console.log(this.name + &quot; 正在吃 &quot;+food);&#125;// 子类function Tiger()&#123;&#125;Tiger.prototype = new Animal();Tiger.prototype.name = &quot;Tiger&quot;;var tiger = new Tiger();console.log(tiger.name);console.log(tiger.eat(&apos;sleep&apos;));console.log(tiger.sleep());console.log(tiger instanceof Animal); //true console.log(tiger instanceof Tiger); //true 效果 ##特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 ##缺点： 可以在子类构造函数中，为子类实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 TODO：写这个的时候还是有点蒙。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中$的实现方式]]></title>
    <url>%2F2018%2F12%2F10%2Fjquery%2F</url>
    <content type="text"><![CDATA[实现方式(网上找的)123456789101112131415161718192021&lt;script&gt; (function(w)&#123; //工厂 function jQuery(selector, context)&#123; return new jQuery.fn.init(selector, context); &#125; //给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; &#125;; //init才是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector, context)&#123; // 构造函数 &#125;; //把构造函数的原型，替换为jQuery工厂的原型 //这么做的目的是为了实现jQuery的插件机制，让外界可以通过jQuery方便的进行扩展 init.prototype = jQuery.fn; w.jQuery = w.$ = jQuery; &#125;(window));&lt;/script&gt; 原链接 1234(function(w)&#123; // dosomthing w.jQuery = w.$ = jQuery; &#125;)(window) 目的：通过全局对象window可以调用对象jQuery或者$ 然后我们声明一个对象jQuery1234(function(w)&#123; function jQuery(selector, context)&#123;&#125; w.jQuery = w.$ = jQuery;&#125;)(window) 效果: 大功告成！但是jQuery显然是更深一层次的做法。示例方式是将原型转换为简化方法fn。然后在jQuery原型上添加一个init方法。 工厂模式什么是工厂模式？怎么在javascript使用？ 工厂模式是用来创建对象的一种最常见的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装到一个函数中，如示例中的jQuery函数，那么这个函数就可以被视为一个工厂。 工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 工厂模式]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapp登录注册时的密码处理思考]]></title>
    <url>%2F2018%2F12%2F07%2Fwebsign%2F</url>
    <content type="text"><![CDATA[webapp在登录的时候怎么控制登录的安全性？ 目前通过https都可以解决这个问题。使用https自动加密传输的数据，从而解决传输密码明文的问题。然后在存储到数据库前通过md5或者其他加密算法进行加密。 #加盐 不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。通常需要对密码加盐，然后进行几次不同加密算法的加密。12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 摘自：interviewmap 不采用http的才使用前端加密后端解密的方式。 题外话：不加https的网站我不用，没有安全锁标志的不用!!! ╭(╯^╰)╮]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualbox-centos7.5-wdcp]]></title>
    <url>%2F2018%2F12%2F04%2Fvirtual-cenos7-5%2F</url>
    <content type="text"><![CDATA[用于记录一次成功使用virtualbox虚拟机安装centos7.5成功联网并安装上wdcp 虚拟机软件当然选免费的了，而且发现好多VMware Workstation的软件链接提示有病毒，qnmlgb老子不用。 centos下载centos7.5-dvd版 要点要点1:虚拟机网卡设置要点2:虚拟机打开网络注：centos默认不启动网卡，需要手动启动路径：123cd /etc/sysconfig/network-scripts/vi ifcfg-xx 找到开头为ifcfg-的，默认是en0输入i进入编辑模式编辑该文件设置ONBOOT=yes:wq 保存退出重启网络1service network restart 有时候要重启虚拟机才能生效。]]></content>
      <categories>
        <category>virtualbox</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[记录markdown的使用方法 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体* 加粗**[要加粗的文字]**用两个*号包起来 斜体*[要斜体的文字]*用一个*号包起来_[要斜体的文字]_用一个_号包起来 斜体加粗***[要斜体加粗的文字]***用三个号包起来**_[要斜体加粗的文字]_**用三个号包起来 删除线~~[要删除线的文字]~~用两个~号包起来 示例：123456**这是加粗的文字***这是倾斜的文字*_这是倾斜的文字_***这是斜体加粗的文字*****_这是斜体加粗的文字_**~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字这是倾斜的文字这是斜体加粗的文字这是斜体加粗的文字这是加删除线的文字 注:加粗hexo不能用 捂脸 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 _。行内不能有其他东西，也可在号中间插入空格。 示例:1234-------******** 效果如下： 注：效果一样 o(￣︶￣)o，hexo 三个-没用 ￣□￣｜｜ 图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：1![小猪佩奇](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1543491437191&amp;di=d1111fbe37d3bd83c8121132d6117c4f&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20180802%2F01%2F1533145434-yGPirmnoVd.jpg &apos;&apos;小猪&apos;&apos;) 效果如下： 超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：1[百度](https://baidu.com &quot;@百度&quot;) 百度 注：Markdown本身语法不支持链接在新页面中打开,如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 列表无序列表使用* - + 作为列表标记注:标记和内容之间要加空格 示例:1234567891011* red* green* yellow- red- green- yellow+ red+ green+ yellow 效果如下: red green yellow red green yellow red green yellow 有序列表使用数字接着一个英文句号注:标记和内容之间要加空格 示例：1233. red2. green1. yellow red green yellow 注:有序的起始数只和第一个有关 表格语法：123456表头|表头|表头|表头---|:--:|---:|:--内容|居中|居右|居左内容|居中|居右|居左-有一个就行 效果如下：表头|表头|表头|表头—|:–:|—:|:–内容|居中|居右|居左内容|居中|居右|居左 注：很显然 hexo并没有用 下划线语法：1&lt;u&gt;123&lt;/u&gt; 效果如下：123注：使用的是html标签 颜色、字体、字体大小语法：12345678910111213&lt;font color=#ee0000 size=9 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=8 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=7 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=6 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=5 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=4 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=3 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=2 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=1 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;color 16进制颜色size 6-1分别对应h1-h6共6个级别face 字体 效果如下： 我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑 代码语法：1234567单行代码`代码内容`多行代码块(```) 代码块(```) 效果如下 单行代码代码内容 多行代码块1代码块 流程图示例：123456789flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果如下flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 注：hexo 不支持]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
