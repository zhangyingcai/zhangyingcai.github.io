<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[new操作符]]></title>
    <url>%2F2019%2F03%2F04%2Fjs-new%2F</url>
    <content type="text"><![CDATA[js中的new操作符 new 的作用12345678// 语法new constructor([arguments]) // new + 构造函数（参数）当代码 `new Foo(...)` 执行时，会发生以下事情：一个继承自 `Foo.prototype` 的新对象被创建。使用指定的参数调用构造函数 `Foo` ，并将 `this` 绑定到新创建的对象。`new Foo` 等同于 `new Foo()`，也就是没有指定参数列表，`Foo` 不带任何参数调用的情况。由构造函数返回的对象就是 `new` 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 123456function create(Con, ...args)&#123; let obj = &#123;&#125; Object.setPrototypeOf(obj, Con.prototype) let result = Con.apply(obj, args) return result instanceof Object ? result : obj&#125; 参考 首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用 然后内部创建一个空对象 obj 因为 obj 对象需要访问到构造函数原型链上的属性，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 * obj.proto = Con.prototype 将 obj 绑定到构造函数上，并且传入剩余的参数 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信分享]]></title>
    <url>%2F2019%2F02%2F27%2Fwx%2F</url>
    <content type="text"><![CDATA[微信分享踩得坑 desc 最好不带中文换行符和单双引号imgurl 最好使用缩略图]]></content>
      <tags>
        <tag>微信分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web-ios]]></title>
    <url>%2F2019%2F02%2F26%2Fweb-ios%2F</url>
    <content type="text"><![CDATA[记录在开发过程中遇到的iOS需要适配的问题 input输入框自动放大的问题mate name=”viewport” 添加 “user-scalable=no” 禁止手动缩放 shrink-to-fit(自适应宽度)下面的代码可以让网页的宽度自动适应手机屏幕的宽度1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; iOS9以上生效要添加”shrink-to-fit=no”原因如下123Viewport meta tags using&quot;width=device-width&quot; cause the page to scale down to fit content that overflows the viewport bounds.You can override this behavior by adding &quot;shrink-to-fit=no&quot; to your meta tag as shown below.The added value will prevent the page from scaling to fit the viewport.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>ios适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购物车]]></title>
    <url>%2F2019%2F02%2F26%2Fshoppingcart%2F</url>
    <content type="text"><![CDATA[关于电商平台购物车的理解 做电商的一般都有购物车的设计，用于记录用户的购买意愿这时候就会涉及到一个库存的问题，因为上架的实际库存是一定的，但是我们怎么设计，在用户添加购物车到下单到付款的体验更优呢？ 这时会有 下单减库存、付款减库存、放进购物车减库存 下单减库存 就是在用户下单的时候减库存，但是用户还没有付款，这笔交易还没有成功，会和12306的抢票是类似的。这个方案无法规避商品恶意被拍的风险。导致真正需要的消费者无法购买，12306的情况就是这样，然后催生了一批刷票的抢(黄)票(牛)软件。然后经常碰到的就是显示的有票，下单无票的情况，体验很差。 付款减库存 只有在消费者付款之后减库存，这样会导致超卖，超卖的订单会提示库存不足，导致用户体验不好。 放进购物车减库存 就是在消费者将商品放进购物车时就减库存。优点：可以在生成订单之前就确定是否有货。缺点是无法规避商品恶意被拍的风险。 淘宝做法：购物车不会减少库存。下单后锁定库存，但是会在相应的购物车和下单时给予用户提示。有一个预售库存到实际库存的过程。 京东：微店中卖家可以设置“拍下减库存”或者“付款减库存”的，并给出想应的优劣分析。 1.拍下减库存买家拍下商品,库存数量就相应减少,24小时后仍未付款,恢复库存数量。好处：保证买家只要拍下宝贝,就一定能买到坏处：1)在库存紧张时,买家拍下之后不付款,会影响其他买家购买 2)可能有人恶意占用库存,给店家造成损失建议：库存充足的店家使用2.付款减库存买家拍下商品，先预扣库存，如果15分钟内付款则减去库存；如果超过15分钟未付款，则释放库存。好处：库存不会被长时间占用,当库存紧张时,真正想买的客户有更多机会买到宝贝坏处：可能出现超卖,最后一个库存被多个客户同时付款,就需要店家和客户协商解决。一般会通过短信和订单详情页提醒的方式通知店家和客户建议：库存紧张、需要防止被占用的店家使用秒杀、限时折扣等活动商品不生效。]]></content>
      <tags>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软实力]]></title>
    <url>%2F2019%2F02%2F26%2Fruanshili%2F</url>
    <content type="text"><![CDATA[做为一个人的软实力 我自己前期自我努力-》给你的学历和天赋（没有学历补学历，没有人脉积累人脉，提高自己的为人处世）当前家庭所在位置-》（提供自己生长环境、人脉、认知、基础）你的后天认知 个人性格随遇而安（不思进取）不善交际（闷）幻想型双鱼座（骚） 解决方案（ToDo）目标：智商情商结交人脉为人处世有眼光有内涵有修养的大叔那些年你偷过的懒和犯过的事都要加倍弥补 学生思维 自我总结现在还有的学生思维，曾经犯过的问题，写到笔记里。制定一个详细的规划，在今年改掉它。 和父母进行一次聊天。去问问你父母在工作职场里都曾经犯过什么学生思维的错误，他们肯定不愿意说，要多问。记录下来，分析一下原因和解决方案。 了解新基建和5g。理解目前a股市场里的相关概念股票，并了解每一个公司的实际业务。但不要随便投资。理解今年的趋势。 本行业理解当前行业的玩法。理解一专一副。理解白天鹅和黑天鹅。 目标：积累资源人脉发现信息差成为黑天鹅。 当前改革削弱部分不应该去（地方权利降低）公务员的话必须是省或者一、二线城市体制内是和城市绑定在一起的，和城市强绑定的，所以选择城市最重要。所以一定要选择当前有实力的，未来有前景的。 行业发展任何行业到了最后都是拼的存量，就是经营自己的黏性用户，所以最后拼的是运营。而技术和产品相对萎缩。 每一个消费升级对应的都有消费降级。消费升级：行业头部，在这个行业头部的这部分人的需求。消费降级：行业底部或者行业外的需求。 选择当前自己适合的当下或者未来有前景的头部行业的头部公司 玩法工作1年-10年 积累的最佳时机： 刚出校园的1-3年 社会没有一个统一的评判标准当前积累自己的软技能和硬技能智商和情商积累加深对社会的理解这是个拉开距离的关键时期（错过了就要加倍的努力）]]></content>
      <categories>
        <category>人性</category>
      </categories>
      <tags>
        <tag>软实力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-element-admin]]></title>
    <url>%2F2019%2F02%2F25%2Fvue-element-admin%2F</url>
    <content type="text"><![CDATA[vue-element-admin的使用总结 基础基于vue2.0,配合使用 Element UI 组件库的一个前端管理后台集成解决方案. 优点：1.权限验证方案。通过配置不同的角色展示不同的页面，可以前后端配合用于权限配置。 权限验证思路：通过获取当前用户的权限，然后去对比路由表，生成当前用户具有的权限可访问路由表，然后通过router.addRoutes动态挂载到router上。]]></content>
      <tags>
        <tag>vue-element-admin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目]]></title>
    <url>%2F2019%2F02%2F21%2Fxm%2F</url>
    <content type="text"><![CDATA[项目心得以及注意事项 表单：1.字段对应的校验，并且在该字段对应出现的位置要同步校验。 版本更新由于文件不同引起的功能差异api文档：https://swagger.io/静态书籍：https://easy-mock.com/login 输入内容校验的问题输入内容只用于展示的问题，将内容转义，或者升级通过innerHTML实现]]></content>
      <tags>
        <tag>项目心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-html]]></title>
    <url>%2F2019%2F02%2F20%2Fjs-html%2F</url>
    <content type="text"><![CDATA[html常用标签的使用与总结 首先要了解的概念块级元素和内联元素123块级元素在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，例如段落、列表、导航菜单、页脚等等。一个以`block`形式展现的块级元素不会被嵌套进内联元素中，但可以嵌套在其它块级元素中。内联元素通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素`&lt;a&gt;`或者强调元素`&lt;em&gt;`和 `&lt;strong&gt;`。 head元素内部base标签1234567891011121314151617181920&lt;base&gt; 标签为页面上的所有的相对链接规定默认 URL 或默认目标。在一个文档中，最多能使用一个 &lt;base&gt; 元素。&lt;base&gt; 标签必须位于 &lt;head&gt; 元素内部。示例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;base href=&quot;http://www.runoob.com//images/&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img src=&quot;logo.png&quot; &gt; - 注意这里我们设置了图片的相对地址。能正常显示是因为我们在 head 部分设置了 base 标签，该标签指定了页面上所有链接的默认 URL，所以该图片的访问地址为 &quot;http://www.runoob.com/images/logo.png&quot;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/&quot;&gt;runoob.com&lt;/a&gt; - 注意这个链接会在新窗口打开，即便它没有 target=&quot;_blank&quot; 属性。因为在 base 标签里我们已经设置了 target 属性的值为 &quot;_blank&quot;。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 示例链接注：base 会默认将base的链接和src、url链接拼接 meta123456用来描述文档的作者、描述、关键字、字符集等等name的关键字有`author` `keywords` `description` &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; 小知识点：每个30秒刷新页面1&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; title1文字的标题 12345定义客户端脚本如果 async=&quot;async&quot;：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）如果不使用 async 且 defer=&quot;defer&quot;：脚本将在页面完成解析时执行如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本 1&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&quot;&gt;]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-regexp]]></title>
    <url>%2F2019%2F02%2F15%2Fjs-regexp%2F</url>
    <content type="text"><![CDATA[常用正则表达式 匹配域名12^((http:\/\/)|(https:\/\/))?([a-zA-Z0-9]([a-zA-Z0-9\-]&#123;0,61&#125;[a-zA-Z0-9])?\.)+[a-zA-Z]&#123;2,6&#125;(/)该表达式可以匹配以http://或者https://开头且支持域名中有中划线的情况，并且会匹配到域名后的第一个/.]]></content>
      <categories>
        <category>JavaScript, Regexp</category>
      </categories>
      <tags>
        <tag>regexp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-dom]]></title>
    <url>%2F2019%2F02%2F14%2Fjs-dom%2F</url>
    <content type="text"><![CDATA[性能提升小技巧 减少dom操作]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>dom操作性能提升</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F13%2Fcss3%2F</url>
    <content type="text"><![CDATA[Document .radius{ width: 100px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ /* border-radius: 100px 50px; */ /* border-top-right-radius: 100px 50px; */ border-radius: 100px 0 0 100px; } /* 添加过渡效果 */ /* -webkit-,-o- */ .circle{ background-color: aqua; width: 50px; height: 50px; border-radius: 50%; transition: all 0.5s; } /* 缩放1.5倍 */ .circle:hover{ transform: scale(1.5); } .nth ul{ list-style: none; } .nth li{ width: 20px; height: 20px; border: 1px solid #666; } .nth a{ display: block; width: 20px; height: 20px; text-align: center; border-radius: 50%; background-color: aquamarine; } /* .nth li:nth-child(n){background-color: black;} */ /* .nth li:nth-child(2n){background-color: black;} */ /* .nth li:nth-child(2n+1){background-color: black;} */ .nth li:nth-child(n+5){background-color: black;} 1 2 3 4 5 6 7 8 9 0 .after::after{ content: '*'; color: red; } .after::before{ content: '&'; color: #666; } .letter::first-letter{ font-size: 35px; color: crimson; font-weight: bold; float: left; } /* 添加float:left首个文字就会下沉 */ .letter::first-line{ color: #f66 } /* 首行 */ 我是一句话额！ .dialog{ width: 200px; height: 50px; line-height: 50px; background-color: #f66; border-radius: 6px; position: relative; } .dialog::before{ content: ''; border-width: 10px; border-color: transparent; border-style: solid; border-right: 10px solid #f66; position: absolute; top: 15px; left: -20px; } .triangle{ width: 0; height: 0px; border-right: 50px solid #f66; border-left: 50px solid transparent; border-top: 50px solid transparent; border-bottom: 50px solid transparent; } 我的小姐姐呢 .diamond{ width: 200px; height: 200px; -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); background-color: aqua; } .parallel{ width: 300px; height: 200px; -ms-transform: skewX(45deg); -moz-transform: skewX(45deg); -webkit-transform: skewX(45deg); -o-transform: skewX(45deg); transform: skewX(45deg); background-color: aqua; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F01%2F24%2Fvue%2F</url>
    <content type="text"><![CDATA[记录vue的知识点 声明式渲染模板语法插值 12345vue.js的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进DOM的系统。&#123;&#123; 参数|单个表达式 &#125;&#125;单个表达式包括：运算、三目运算&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; // 将字符串翻转 vue的生命周期beforeCreate // 实例初始化之后，数据观测和事件配置之前，也就是说这时候是不能获取数据和事件的created // 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。beforeMount // 在挂载开始之前被调用：相关的 render 函数首次被调用。mounted // el 被新创建的vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。beforeUpdate // 数据更新前updated // 数据更新后beforeDestroy // 销毁之前 适合移除时间、定时器 可能会引起内存泄漏destroyed // 销毁 在销毁组件，如果有子组件的话，会递归销毁子组件，直到所有的子组件都销毁完毕之后执行 v-show12`v-show`始终渲染元素，通过切换display来控制元素的显示隐藏，有较大的初始渲染开销。注意，`v-show` 不支持 `&lt;template&gt;` 元素，也不支持 `v-else`。 v-if1`v-if`指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候被渲染。 v-model1实现双向绑定 可以添加修饰符 .trim123如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：`&lt;input v-model.trim=&quot;msg&quot;&gt;` .number12345如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：`&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;`这通常很有用，因为即使在 `type=&quot;number&quot;` 时，`HTML` 输入元素的值也总会返回字符串。如果这个值无法被 `parseFloat()` 解析，则会返回原始的值。(说明`number`的实现是通过`parseFloat()`方法实现的) .lazy12在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 。添加`lazy`从而转变为使用`change`时间进行同步，也就是在每次改变的时候进行同步。 v-once1只赋值一次 事件修饰符.prevent12`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt; 12345678910111213141516171819&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 计算属性语法123456789101112&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;computed:&#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; // 关键字computed，是vue的一个属性 计算属性的setter12345678910111213141516计算属性默认只有getter,不过在需要时你也可以提供一个settercomputed: &#123; fullName: &#123; // 计算属性 // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;现在再运行 vm.fullName = &apos;John Doe&apos; 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 目的：替换模板语法的复杂逻辑 计算属性缓存 vs 方法123456789最终结果是完全相同的。不同的计算属性是基于他们的依赖进行缓存的。只有在相应的依赖发生改变时计算属性才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。调用方法总会再次执行函数。computed: &#123; now: function () &#123; return Date.now() &#125;&#125;// 只会返回第一次的时间。 计算属性 vs 倾听属性12345678910111213141516171819vue提供了一种更通用的方式观察和响应vue实例上的数据变化。当你有一些数据需要随着其他数据的变化而变化时，很容易滥用watch,通常使用computed。var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; // 监听某个数据改变 this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125;&#125;) 倾听器]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-api]]></title>
    <url>%2F2019%2F01%2F23%2Fjs-api%2F</url>
    <content type="text"><![CDATA[用于平常学到的js知识点 Array.prototype.includesmdn 语法：12345arr.includes(searchElement)arr.includes(searchElement, fromIndex)返回值：Boolean 用于判断数组中是否存在某个值 includes() 作为一个通用方法includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的arguments对象上调用的includes() 方法。 1234(function() &#123; console.log([].includes.call(arguments, &apos;a&apos;)); // true console.log([].includes.call(arguments, &apos;d&apos;)); // false&#125;)(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); element.scrollIntoView() 让当前的元素滚动到浏览器窗口的可视区域语法123element.scrollIntoView(); // 等同于element.scrollIntoView(true) element.scrollIntoView(alignToTop); // Boolean型参数 element.scrollIntoView(scrollIntoViewOptions); // Object型参数 mdn 同源策略mdn(https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy) 同源策略限制了从同一个源加载的文件和脚本如何同另一个源加载的文件进行交互。 同源的定义： 协议、端口、域名完全相同的两个页面，称这两个页面具有相同的源。 源的继承： about:blank]]></content>
      <tags>
        <tag>jsapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2019%2F01%2F17%2Fes6%2F</url>
    <content type="text"><![CDATA[es6笔记 变量提升英文：Hoisting 很有意思的题目 变量提升变量和函数的声明移动到当前执行上下文(块)的最前面。应用范围：数据类型、变量、函数 runtime：1.并不是物理位置的移动，而是在编译阶段被放到内存中。2.仅提升声明，而不提示初始化 历史原因：提升存在的根本原因就是为了解决函数间互相调用的情况 12345678&#123; catName(&quot;Chloe&quot;); function catName(name) &#123; console.log(&quot;我的猫名叫 &quot; + name); &#125;&#125;catName(&quot;Tom&quot;); 1234567function test1() &#123; test2()&#125;function test2() &#123; test1()&#125;test1() let 不存在 Hoistingvar 在全局作用域下声明变量会导致变量挂载在 window 上，let`const`两者不会 tomdn 暂时性死区let、const 因为暂时性死区的原因，不能在声明前使用 在 ECMAScript 6 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 tomdn 原型继承立即执行函数历史原因：用于模块化，通过函数作用域解决命名冲突、污染全局作用域的问题。1(function()&#123;&#125;)()]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[date]]></title>
    <url>%2F2019%2F01%2F15%2Fvue-date%2F</url>
    <content type="text"><![CDATA[date.js 处理日期的函数 12345678910111213141516171819202122232425262728293031export function formatDate(date, fmt) &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)) &#125; const o = &#123; &apos;M+&apos;: date.getMonth() + 1, &apos;d+&apos;: date.getDate(), &apos;h+&apos;: date.getHours(), &apos;m+&apos;: date.getMinutes(), &apos;s+&apos;: date.getSeconds() &#125; for (const k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; const str = o[k] + &apos;&apos; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str) &#123; return (&apos;00&apos; + str).substr(str.length)&#125;// 用法// 可以使用filterdateFilter(number) &#123; // js默认是毫秒，先转换为毫秒 const date = new Date(number * 1e3) return formatDate(date, &apos;yyyy.MM.dd hh:mm:ss&apos;)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2019%2F01%2F15%2Fvue-router%2F</url>
    <content type="text"><![CDATA[vue-router的使用总结 传参普通模式（传单个值）123456789101112//《路由》/:id// 通过在路由后面添`/:id`,`id`是参数名称// 传参`:to=&quot;&apos;/user/&apos;+id&quot;`// 获取`$route.params.id`const User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;) 进阶模式使用props将组件和路由解耦 12345678910111213141516171819// User组件// 需要将id传入User组件// 作为User组件的属性直接使用const User = &#123; props: [&apos;id&apos;], template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: &apos;/user/:id&apos;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 对象有的时候我们要传递一个对象到一个页面或者一个组件 123456789// 通过:to=&apos;/search?q=vue&amp;other=name&apos;将对象拆分传递// 可以看到vue-router已经将我们的参数编码了const router = new VueRouter(&#123; routes: [ // 我们可以通过props转换成需要的状态 // 在组件通过props获取 &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) 通过组件props获取的传参是不可修改的，可以在子组件新建变量接受参数。12345data()&#123; return &#123; currentQ:this.q &#125;&#125; 然后就可以对他进行修改了。猜测是const类型 todo:了解原理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2019%2F01%2F11%2Fnginx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2019%2F01%2F10%2Fcss%2F</url>
    <content type="text"><![CDATA[用于记录css遇到的问题 button123456typebutton的类型。可选值：* submit: 此按钮将表单数据提交给服务器。如果未指定属性，或者属性动态更改为空值或无效值，则此值为默认值。* reset: 此按钮重置所有组件为初始值。* button: 此按钮没有默认行为。它可以有与元素事件相关的客户端脚本，当事件出现时可触发。* menu: 此按钮打开一个由指定&lt;menu&gt;元素进行定义的弹出菜单。 注：默认为submit可以出发输入框回车事件。 text-overflowrunoob语法 123属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号（&apos;...&apos;，U + 2026 HORIZONTAL ELLIPSIS）或显示一个自定义字符串。这个属性并不会强制&quot;溢出&quot;事件的发生，因此为了能让&quot;text-overflow&quot;能够生效，程序员们必须要在元素上添加几个额外的属性，比如&quot;将overflow 设置为hidden&quot;。 省略号123456789101112131415&#123; -webkit-text-overflow: ellipsis; text-overflow: ellipsis; overflow: hidden;&#125;单行省略&#123; white-space: nowrap; // 不换行 width: 10rem; -webkit-text-overflow: ellipsis; text-overflow: ellipsis; overflow: hidden;&#125;注：需要适配浏览器 图片自适应一般是控制宽度高度自适应 用代码翻译一下就是12max-width: 100%;height: auto; display12345默认 inline // 元素会被显示为内联元素，元素前后没有换行符。block // 元素被显示为块级元素，元素前后有换行符none // 元素不显示，也不占空间inherit // 元素继承父元素的属性inline-block // 行内块元素 word-break12345指定了在单词内断行normal // 使用默认的断行规则break-all // 可在任意字符间断行keep-all // 文本不断行break-word // 断行，但是不会断单个单词 css3新特性用于那些属性需要添加前缀-can i use 圆角12345678910111213141516171819div&#123; border:2px solid; border-radius: 25px;&#125;div&#123; border-top-left-radius: 50%;&#125;.radius&#123; width: 200px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ border-radius: 100px 100px 50px 20px; // top left 左上角开始顺时针旋转 border-radius: 100px 50px; //分别代表斜对角的radius值 border-top-left-radius: 100px 50px; // 分别代表椭圆的x(横)和y(纵)当两者相等时画出的是圆角 &#125;注 50%是画圆 半圆123456789.radius&#123; width: 100px; height: 200px; background-color: aqua; /* border-top-left-radius: 100px; */ /* border-top-right-radius: 100px; */ /* border-radius: 100px 50px; */ border-radius: 100px 0 0 100px; &#125; 伪类选择器列表 12345678a:linka:visited // 链接点击过之后的颜色a:hover // 鼠标在元素上的颜色a:active // 鼠标左键长按的颜色状态伪类选择器input:enabledinput:disabled 隔行换色123456789101112131415161718语法:nth-child(2) //选择第二个:nth-child(2n) //选择所有偶数行:nth-child(2n+1) //选择所有基数行:nth-child(n+5) //选择从第五行开始:nth-child(n) //全选:nth-last-child() // 和上面相同，从最后一个子元素开始算// 上面计数时包括当前标签里的所有类型的元素都会计数// 所以都是相同元素的时候没有影响:nth-of-type() // 从当前限定的元素类型开始计算，用法同上:nth-last-of-type():first-of-type():last-of-type():only-child() // 当前只有一个子元素时:only-of-type() // 当前只有一个子元素并且是当前限定的元素类型 伪元素mdn伪类和伪元素 123456789语法：跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 `::` ， 同样是添加到选择器后面去选择某个元素的某个部分。::after::before::first-letter::first-line::selection::backdrop 示例12345678910111213&lt;style&gt;.letter::first-letter&#123; font-size: 35px; color: crimson; font-weight: bold; float: left;&#125;/* 添加float:left首个文字就会下沉 */.letter::first-line&#123; color: #f66&#125;/* 首行 */&lt;/style&gt; 1234::after&#123; content:url();&#125;::before // 这两个元素在使用时必须有content 画对话框123456789101112131415161718.dialog&#123; width: 200px; height: 50px; line-height: 50px; background-color: #f66; border-radius: 6px; position: relative; &#125; .dialog::before&#123; content: &apos;&apos;; border-width: 10px; border-color: transparent; border-style: solid; border-right: 10px solid #f66; position: absolute; top: 15px; left: -20px; &#125; 画菱形和平行四边形要考虑样式的兼容性。12345678910111213141516171819202122画菱形的思路：先画个正方形旋转45度。 单位deg .diamond&#123; width: 200px; height: 200px; -ms-transform: rotate(45deg); -moz-transform: rotate(45deg); -webkit-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg); background-color: aqua; &#125;平行四边形使用倾斜.parallel&#123; width: 300px; height: 200px; -ms-transform: skewX(45deg); -moz-transform: skewX(45deg); -webkit-transform: skewX(45deg); -o-transform: skewX(45deg); transform: skewX(45deg); background-color: aqua; &#125; 五角星和六角星发光字体、立体字runoob 1234567text-shadow: h-shadow v-shadow blur color;h-shadow 必需。水平阴影的位置。允许负值。v-shadow 必需。垂直阴影的位置。允许负值。blur 可选。模糊的距离。color 可选。阴影的颜色。参阅 CSS 颜色值。` rem设置基准然后根据基准计算。123html&#123; font-size:62.5%; // 10/16*100% 默认16px&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2019%2F01%2F03%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp使用记录并形成自己的一套插件 复制文件]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm]]></title>
    <url>%2F2019%2F01%2F03%2Fnpm%2F</url>
    <content type="text"><![CDATA[世界上最大的软件注册表(做JavaScript的都要懂得) npm由三个部分组成 网站 注册表（registry） 命令行工具（CLI）]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 基础]]></title>
    <url>%2F2018%2F12%2F26%2Fjs-base%2F</url>
    <content type="text"><![CDATA[基础 原始类型原始类型是那几种？null是对象吗？ 6种 number string boolean null undefined symbol 我的理解： number 9527 string ‘9527’,”9527” boolean true,false Null null undefined symbol （ECMAScript 6新定义） 首先，原始类型存储的都是值，是没有函数可以调用的。 12undefined.toString()null.toString() 会报Cannot read property &#39;toString&#39; of null这个错误。此时你肯定会有意外，比如下面这种情况为什么这时候的&#39;1&#39;是可以调用这么多函数的？其实在这种情况下，&#39;1&#39;已经不是原始类型了，而是被强制转换成了String类型，也就是对象类型，所以可以调用toString函数。 除了会在必要的情况下强制转换类型以外，原始类型还有一些坑。 number类型是浮点类型的，在使用的过程中会遇到某些bug，比如0.1+0.2!=0.3。string类型是不可变的，无论你在string类型上调用任何方法，都不会对值有改变。除 Object 以外的所有类型都是不可变的，这里是值本身无法被改变。JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变，然后这些类型的值被称为”原始值”。null有的人会认为他是object,其实这是历史遗留问题。虽然typeof null会输出object。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 拓展： 最新的 ECMAScript 标准定义了 7 种数据类型:包括以上6种类型和object。 对象类型对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ js中除了原始类型之外的其他的都是原始类型。不同：原始类型存储的是值，对象类型存储的是地址。函数参数是对象会发生，函数中修改了参数值，对象的值也跟着改变。 小题：12345678910111213141516function test(person) &#123; person.age = 26 person = &#123; name: &apos;yyy&apos;, age: 30 &#125; return person&#125;const p1 = &#123; name: &apos;yck&apos;, age: 25&#125;const p2 = test(p1)console.log(p1) // -&gt; ?console.log(p2) // -&gt; ? 通过字面量创建的是一个新对象。 在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。 typeof vs instanceof语法：1234567typeof operandoperand:对象或者原始值instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置object instanceof constructorobject: 要检测的对象 // 必须是对象呢constructor: 某个构造函数 instanceof 典型的用法是判断是否继承关系，用于测试对象是不是特定构造函数的实例。 实现instanceof12345678910111213function myinstanceof(obj, constructor)&#123; const prototype = constructor.prototype let obj = obj.__proto__ // 获取原型对象 while(true)&#123; if(obj === null || typeof obj !== &apos;Object&apos;)&#123; // 去除Null和不是对象的情况 return false &#125; if(_proto === prototype)&#123; return true &#125; obj = obj.__proto__ &#125;&#125; 类型转换在js中类型转换只有三种情况。 转换成boolean 转换成string 转换成number 转换成boolean this 在绝大多数情况下，函数的调用方式决定了this的值。this不能再执行期间被赋值，并且在函数每次函数被调用时this的值可能不会相同。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行环境内设置this的值）。 全局环境 无论是否在严格模式下，在全局执行环境中this指向全局函数。 在严格模式下，this将保持他执行环境的值。如果this没有被环境定义，那他将保持为undefined。 12345678910function f1()&#123; return this;&#125;f1(); // windowfunction f2()&#123; &apos;use strict&apos;; return this;&#125;f2(); // undefined 因为f2是被直接调用的，而不是作为对象的属性或方法调用的。 如果想把this的值从一个环境传到另一个环境，就需要使用call或者apply。 12345678var obj = &#123;a:&apos;custom&apos;&#125;;var a = &apos;global&apos;;function whatsThis(arg)&#123; return this.a;&#125;whatsThis(); // &apos;global&apos;whatsThis.call(obj); // &apos;custom&apos;whatsThis.apply(obj); // &apos;custom&apos; 当一个函数在其主体中使用this关键字时，可以通过使用函数继承自function.prototype的call或apply方法将this绑定到调用中的特定对象。也就是调用call或apply方法绑定到调用的对象上。123456789101112131415function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用// call(obj,...arguments)add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数// apply(obj,[...arguments])add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 注：使用call和apply时，如果传递给this的不是一个对象，javascript会使用相关构造函数将其转换为对象。 es5引入了function.prototype.bind。调用f.bind(someObject)会创建一个和f具有相同函数体和作用域的函数，但是在这个新函数中，this被永久性的绑定到了bind第一个参数上。 123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&apos;yoo&apos;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty es6箭头函数：this与封闭词法环境中的this保持一致。全局代码中是window。 当代码被内联on-event函数调用时，this指向监听器当前所在的dom。注意: 只有最外层的this是这样设置的。12345678910&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; Show this&lt;/button&gt;// dom&lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt; Show inner this&lt;/button&gt;// 等同于alert((function()&#123;return this&#125;)()); // windowalert((function()&#123;&apos;use strict&apos;; return this&#125;)()); // undefined 参见this详解 == 和 === 的区别问题：[]==![]的结果是什么，[]==[]呢? 参见比较运算符详解 JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。 字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。 比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后得到被四舍五入后的数字类型的值。如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。如果一个对象与数字或字符串相比较，JavaScript会尝试返回对象的默认值。操作符会尝试通过方法valueOf和toString将对象转换为其原始值（一个字符串或数字类型的值）。如果尝试转换失败，会产生一个运行时错误。注意：当且仅当与原始值比较时，对象会被转换为原始值。当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true。 类型转换 深浅拷贝assign详解 概念深拷贝：对象类型赋值时新建一个对象，分配了内存，指向不同的对象互不干扰浅拷贝：对象类型赋值时复制了地址，指向同一个对象，改了一个另外一个也发生改变 浅拷贝通过Object.assign实现1针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。 语法Object.assign(target, …sources)参数target目标对象。sources源对象。 返回值目标对象。 深拷贝通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。参考但是也有局限性 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 推荐使用lodash的深拷贝函数 构造函数创建对象的两种方法：字面量方法和构造函数 123456function createPerson(name)&#123; this.name = name; this.greeting = function()&#123; alert(&apos;Hi! I&apos;m &apos;+name+&apos;.&apos;); &#125;&#125; 当你输入网址的时候发生了什么答案在这 http2比http1快了多少here 123456789101112优化了哪些？http1请求是队头阻塞的,http2复用同一个tcp链接http2引入了新的编码机制，并采用二进制传输http2通过引入`帧`和`流`的方式实现多路复用http2对header进行了压缩新的问题原因：使用的tcp，如果出现丢包的情况，该条线路就会进入阻塞状态，等待重传。http3采用QUIC QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议 绝对路径与相对路径1234相对路径./ 当前目录../ 父级目录/ 当前项目的根目录 location属性123location.search //返回`?`以及`?`以后的部分location.hash // 返回一个URL的锚部分location.host // 返回一个URL的主机名 判断一个对象是否有值1Object.keys(obj).length // es6 Number 和 0奇怪的用法12345678// 转义function htmlEncodeJQ ( str ) &#123; return $(&apos;&lt;span/&gt;&apos;).text( str ).html();&#125;// 解码function htmlDecodeJQ ( str ) &#123; return $(&apos;&lt;span/&gt;&apos;).html( str ).text();&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原始类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程师必须懂得概念（一）]]></title>
    <url>%2F2018%2F12%2F20%2Fjs-call-stack%2F</url>
    <content type="text"><![CDATA[调用堆栈 调用栈是解析器的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数在执行，什么函数被这个函数调用，下一个调用的函数是谁。） 当脚本要执行一个函数时，解析器把该函数添加到栈中并执行 任何被这个函数调用的函数会进一步添加到调用栈中，并且会运行到他们被上个程序调用的位置 当函数运行结束后，解释器将他从调用栈中取出，并在主代码列表中继续执行代码 如果栈调用的空间比分配给它的内存空间大，则会导致”栈溢出”]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>call stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的事件注册机制]]></title>
    <url>%2F2018%2F12%2F20%2Fbrowser-event%2F</url>
    <content type="text"><![CDATA[记录学习浏览器的事件注册机制 事件触发的三个阶段 window向事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处触发注册的事件 从事件触发处向window传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 1234567// 以下会先打印冒泡然后是捕获node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;冒泡&apos;)&#125;,false);node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;捕获 &apos;)&#125;,true) 那么我们怎么区分注册的事件是冒泡事件还是捕获事件？ 我们通常使用addEventListener注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture，布尔值，和 useCapture 作用一样 once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 12345678node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; event.stopImmediatePropagation() console.log(&apos;冒泡&apos;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&apos;click&apos;,(event) =&gt; &#123; console.log(&apos;捕获 &apos;)&#125;,true) stopPropagation只能阻止事件的进一步传播，默认注册的事件还是会执行。和他相反的是preventDefault方法，用于阻止默认事件的执行，但是会发送事件的进一步传播，通常是对注册事件重新定义时使用。return false;就等于同时调用了event.stopPropagation()和event.preventDefault()，即会阻止事件冒泡也会阻止默认事件。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>browser event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-bibao%2F</url>
    <content type="text"><![CDATA[闭包 函数A返回了函数B,并且函数B使用了函数A的变量，函数B就成为闭包。 1234567function A()&#123; let a = 1; function B()&#123; console.log(a); &#125; return B();&#125; 为什么函数A已经调用出栈了，为什么函数B还能引用到函数A中的变量。是否和我有相同的疑问？因为函数A中的变量这时候是存储在堆上的，现在的js引擎可以通过逃逸分析辨别出那些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2018%2F12%2F17%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[promise是ES6新增的语法，解决了回调地狱的问题。 可以吧Promise看成一个状态机。初始是 pending(挂起) 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 三种状态const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;// promise 接收一个函数参数，该函数会立即执行function MyPromise(fn) &#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) &#125; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125;; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125; // 用于解决以下问题 // new Promise(() =&gt; throw Error(&apos;error)) try &#123; fn(_this.resolve, _this.reject); &#125; catch (e) &#123; _this.reject(e); &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123; var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) =&gt; console.log(value)) onResolved = typeof onResolved === &apos;function&apos; ? onResolved : v =&gt; v; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; throw r; if (self.currentState === RESOLVED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () &#123; try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function () &#123; // 考虑到可能会有报错，所以使用 try/catch 包裹 try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); self.rejectedCallbacks.push(function () &#123; try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123; // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) &#123; return reject(new TypeError(&quot;Error&quot;)); &#125; // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; // 规范 2.3.3.2，如果不能取出 then，就 reject try &#123; // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === &quot;function&quot;) &#123; // 规范 2.3.3.3 then.call( x, y =&gt; &#123; if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ); &#125; else &#123; // 规范 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 规范 2.3.4，x 为基本类型 resolve(x); &#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用栈实现队列]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-quene%2F</url>
    <content type="text"><![CDATA[先上代码 1234567891011121314151617181920212223function Quene() &#123; var stack1 = [], stack2 = [] this.push = function(node) &#123; stack1.push(node) &#125; this.pop = function() &#123; if (stack2.length == 0) &#123; if (stack1.length == 0) &#123; return null &#125; else &#123; var len = stack1.length for (var i = 0; i &lt; len; i++) &#123; stack2.push(stack1.pop()) &#125; return stack2.pop() &#125; &#125; else &#123; return stack2.pop() &#125; &#125;&#125; 栈有入栈和出栈，实现队列就是将两个栈，通过栈顶和另一个的栈底相连，然后一个栈一直执行入栈，另一个一直执行出栈就可以了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>quene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js实现单例模式]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-single%2F</url>
    <content type="text"><![CDATA[先上代码：惰性单例的精髓！！！ 1234567//单例模式抽象，分离创建对象的函数和判断对象是否已经创建var getSingle = function(fn)&#123; var result; return function()&#123; return result || (result = fn.apply(this, arguments)); &#125;&#125; 形参fn是我们的构造函数，我们只要传入任何自己需要的构造函数，就能生成一个新的惰性单例。比如说传入创建一个女朋友的构造函数，并且调用getSingle(),就能生成一个新的女朋友。如果以后再调getSingle(),也只会返回刚才创建的那个女朋友。至于新女朋友——不存在的。]]></content>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[Document .triangle{ height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } .box{ width: 0px; height: 0px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[用css画三角形]]></title>
    <url>%2F2018%2F12%2F11%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[1234567.triangle&#123; height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red;&#125; 画出的是一个倒立的三角形, 改为border-bottom就是一个正立的三角形。其中是底边为100px,高度为100px的等腰三角形。 border画多边形的原理123456789.box&#123; width: 100px; height: 100px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125; 盒子模型 如上图的盒子模型，可以明显的看出，border实际上是一个等腰梯形。 当宽度为0时 宽度为0 四个边框变成四个等腰三角形。 TODO：继续深入了解，解决梯形的问题 当width和height为0时，默认是四个三角形，当宽度或高度不为0的时候，就可以画出梯形。 123456789.box&#123; width: 100px; height: 0; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中一般怎么实现继承]]></title>
    <url>%2F2018%2F12%2F10%2Fjs-super%2F</url>
    <content type="text"><![CDATA[学习一下js的继承实现。 123456789101112131415161718192021222324function Animal(name)&#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &quot; 正在睡觉。&quot;); &#125;&#125; // 原型方法 Animal.prototype.eat = function(food)&#123; console.log(this.name + &quot; 正在吃 &quot;+food);&#125;// 子类function Tiger()&#123;&#125;Tiger.prototype = new Animal();Tiger.prototype.name = &quot;Tiger&quot;;var tiger = new Tiger();console.log(tiger.name);console.log(tiger.eat(&apos;sleep&apos;));console.log(tiger.sleep());console.log(tiger instanceof Animal); //true console.log(tiger instanceof Tiger); //true 效果 ##特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 ##缺点： 可以在子类构造函数中，为子类实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 TODO：写这个的时候还是有点蒙。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中$的实现方式]]></title>
    <url>%2F2018%2F12%2F10%2Fjquery%2F</url>
    <content type="text"><![CDATA[实现方式(网上找的)123456789101112131415161718192021&lt;script&gt; (function(w)&#123; //工厂 function jQuery(selector, context)&#123; return new jQuery.fn.init(selector, context); &#125; //给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; &#125;; //init才是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector, context)&#123; // 构造函数 &#125;; //把构造函数的原型，替换为jQuery工厂的原型 //这么做的目的是为了实现jQuery的插件机制，让外界可以通过jQuery方便的进行扩展 init.prototype = jQuery.fn; w.jQuery = w.$ = jQuery; &#125;(window));&lt;/script&gt; 原链接 1234(function(w)&#123; // dosomthing w.jQuery = w.$ = jQuery; &#125;)(window) 目的：通过全局对象window可以调用对象jQuery或者$ 然后我们声明一个对象jQuery1234(function(w)&#123; function jQuery(selector, context)&#123;&#125; w.jQuery = w.$ = jQuery;&#125;)(window) 效果: 大功告成！但是jQuery显然是更深一层次的做法。示例方式是将原型转换为简化方法fn。然后在jQuery原型上添加一个init方法。 工厂模式什么是工厂模式？怎么在javascript使用？ 工厂模式是用来创建对象的一种最常见的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装到一个函数中，如示例中的jQuery函数，那么这个函数就可以被视为一个工厂。 工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 工厂模式 toggle 切换显示/隐藏mdn类似的例子]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapp登录注册时的密码处理思考]]></title>
    <url>%2F2018%2F12%2F07%2Fwebsign%2F</url>
    <content type="text"><![CDATA[webapp在登录的时候怎么控制登录的安全性？ 目前通过https都可以解决这个问题。使用https自动加密传输的数据，从而解决传输密码明文的问题。然后在存储到数据库前通过md5或者其他加密算法进行加密。 #加盐 不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。通常需要对密码加盐，然后进行几次不同加密算法的加密。12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 摘自：interviewmap 不采用http的才使用前端加密后端解密的方式。 题外话：不加https的网站我不用，没有安全锁标志的不用!!! ╭(╯^╰)╮]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualbox-centos7.5-wdcp]]></title>
    <url>%2F2018%2F12%2F04%2Fvirtual-cenos7-5%2F</url>
    <content type="text"><![CDATA[用于记录一次成功使用virtualbox虚拟机安装centos7.5成功联网并安装上wdcp 虚拟机软件当然选免费的了，而且发现好多VMware Workstation的软件链接提示有病毒，qnmlgb老子不用。 centos下载centos7.5-dvd版 要点要点1:虚拟机网卡设置要点2:虚拟机打开网络注：centos默认不启动网卡，需要手动启动路径：123cd /etc/sysconfig/network-scripts/vi ifcfg-xx 找到开头为ifcfg-的，默认是en0输入i进入编辑模式编辑该文件设置ONBOOT=yes:wq 保存退出重启网络1service network restart 有时候要重启虚拟机才能生效。]]></content>
      <categories>
        <category>virtualbox</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[记录markdown的使用方法 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体* 加粗**[要加粗的文字]**用两个*号包起来 斜体*[要斜体的文字]*用一个*号包起来_[要斜体的文字]_用一个_号包起来 斜体加粗***[要斜体加粗的文字]***用三个号包起来**_[要斜体加粗的文字]_**用三个号包起来 删除线~~[要删除线的文字]~~用两个~号包起来 示例：123456**这是加粗的文字***这是倾斜的文字*_这是倾斜的文字_***这是斜体加粗的文字*****_这是斜体加粗的文字_**~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字这是倾斜的文字这是斜体加粗的文字这是斜体加粗的文字这是加删除线的文字 注:加粗hexo不能用 捂脸 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 _。行内不能有其他东西，也可在号中间插入空格。 示例:1234-------******** 效果如下： 注：效果一样 o(￣︶￣)o，hexo 三个-没用 ￣□￣｜｜ 图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：1![小猪佩奇](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1543491437191&amp;di=d1111fbe37d3bd83c8121132d6117c4f&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20180802%2F01%2F1533145434-yGPirmnoVd.jpg &apos;&apos;小猪&apos;&apos;) 效果如下： 超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：1[百度](https://baidu.com &quot;@百度&quot;) 百度 注：Markdown本身语法不支持链接在新页面中打开,如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 列表无序列表使用* - + 作为列表标记注:标记和内容之间要加空格 示例:1234567891011* red* green* yellow- red- green- yellow+ red+ green+ yellow 效果如下: red green yellow red green yellow red green yellow 有序列表使用数字接着一个英文句号注:标记和内容之间要加空格 示例：1233. red2. green1. yellow red green yellow 注:有序的起始数只和第一个有关 表格语法：123456表头|表头|表头|表头---|:--:|---:|:--内容|居中|居右|居左内容|居中|居右|居左-有一个就行 效果如下：表头|表头|表头|表头—|:–:|—:|:–内容|居中|居右|居左内容|居中|居右|居左 注：很显然 hexo并没有用 下划线语法：1&lt;u&gt;123&lt;/u&gt; 效果如下：123注：使用的是html标签 颜色、字体、字体大小语法：12345678910111213&lt;font color=#ee0000 size=9 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=8 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=7 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=6 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=5 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=4 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=3 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=2 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=1 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;color 16进制颜色size 6-1分别对应h1-h6共6个级别face 字体 效果如下： 我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑 代码语法：1234567单行代码`代码内容`多行代码块(```) 代码块(```) 效果如下 单行代码代码内容 多行代码块1代码块 流程图示例：123456789flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果如下flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 注：hexo 不支持]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
