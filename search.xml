<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gulp]]></title>
    <url>%2F2019%2F01%2F03%2Fgulp%2F</url>
    <content type="text"><![CDATA[gulp使用记录并形成自己的一套插件 复制文件]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm]]></title>
    <url>%2F2019%2F01%2F03%2Fnpm%2F</url>
    <content type="text"><![CDATA[世界上最大的软件注册表(做JavaScript的都要懂得) npm由三个部分组成 网站 注册表（registry） 命令行工具（CLI）]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 基础]]></title>
    <url>%2F2018%2F12%2F26%2Fjs-base%2F</url>
    <content type="text"><![CDATA[基础 原始类型原始类型是那几种？null是对象吗？ 6种 number string boolean null undefined symbol 我的理解： number 9527 string ‘9527’,”9527” boolean true,false Null null undefined symbol （ECMAScript 6新定义） 首先，原始类型存储的都是值，是没有函数可以调用的。 12undefined.toString()null.toString() 会报Cannot read property &#39;toString&#39; of null这个错误。此时你肯定会有意外，比如下面这种情况为什么这时候的&#39;1&#39;是可以调用这么多函数的？其实在这种情况下，&#39;1&#39;已经不是原始类型了，而是被强制转换成了String类型，也就是对象类型，所以可以调用toString函数。 除了会在必要的情况下强制转换类型以外，原始类型还有一些坑。 number类型是浮点类型的，在使用的过程中会遇到某些bug，比如0.1+0.2!=0.3。string类型是不可变的，无论你在string类型上调用任何方法，都不会对值有改变。除 Object 以外的所有类型都是不可变的，这里是值本身无法被改变。JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变，然后这些类型的值被称为”原始值”。null有的人会认为他是object,其实这是历史遗留问题。虽然typeof null会输出object。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 拓展： 最新的 ECMAScript 标准定义了 7 种数据类型:包括以上6种类型和object。 对象类型对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ js中除了原始类型之外的其他的都是原始类型。不同：原始类型存储的是值，对象类型存储的是地址。函数参数是对象会发生，函数中修改了参数值，对象的值也跟着改变。 小题：12345678910111213141516function test(person) &#123; person.age = 26 person = &#123; name: &apos;yyy&apos;, age: 30 &#125; return person&#125;const p1 = &#123; name: &apos;yck&apos;, age: 25&#125;const p2 = test(p1)console.log(p1) // -&gt; ?console.log(p2) // -&gt; ? 通过字面量创建的是一个新对象。 在 Javascript 里，对象可以被看作是一组属性的集合。用对象字面量语法来定义一个对象时，会自动初始化一组属性。 typeof vs instanceof语法：1234567typeof operandoperand:对象或者原始值instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置object instanceof constructorobject: 要检测的对象constructor: 某个构造函数 instanceof 典型的用法是判断是否继承关系，用于测试对象是不是特定构造函数的实例。 类型转换在js中类型转换只有三种情况。 转换成boolean 转换成string 转换成number 转换成boolean this 在绝大多数情况下，函数的调用方式决定了this的值。this不能再执行期间被赋值，并且在函数每次函数被调用时this的值可能不会相同。ES5引入了bind方法来设置函数的this值，而不用考虑函数如何被调用的ES2015 引入了支持this词法解析的箭头函数（它在闭合的执行环境内设置this的值）。 全局环境 无论是否在严格模式下，在全局执行环境中this指向全局函数。 在严格模式下，this将保持他执行环境的值。如果this没有被环境定义，那他将保持为undefined。 12345678910function f1()&#123; return this;&#125;f1(); // windowfunction f2()&#123; &apos;use strict&apos;; return this;&#125;f2(); // undefined 因为f2是被直接调用的，而不是作为对象的属性或方法调用的。 如果想把this的值从一个环境传到另一个环境，就需要使用call或者apply。 12345678var obj = &#123;a:&apos;custom&apos;&#125;;var a = &apos;global&apos;;function whatsThis(arg)&#123; return this.a;&#125;whatsThis(); // &apos;global&apos;whatsThis.call(obj); // &apos;custom&apos;whatsThis.apply(obj); // &apos;custom&apos; 当一个函数在其主体中使用this关键字时，可以通过使用函数继承自function.prototype的call或apply方法将this绑定到调用中的特定对象。也就是调用call或apply方法绑定到调用的对象上。123456789101112131415function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用// call(obj,...arguments)add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数// apply(obj,[...arguments])add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 注：使用call和apply时，如果传递给this的不是一个对象，javascript会使用相关构造函数将其转换为对象。 es5引入了function.prototype.bind。调用f.bind(someObject)会创建一个和f具有相同函数体和作用域的函数，但是在这个新函数中，this被永久性的绑定到了bind第一个参数上。 123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:&apos;yoo&apos;&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty es6箭头函数：this与封闭词法环境中的this保持一致。全局代码中是window。 当代码被内联on-event函数调用时，this指向监听器当前所在的dom。注意: 只有最外层的this是这样设置的。12345678910&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; Show this&lt;/button&gt;// dom&lt;button onclick=&quot;alert((function()&#123;return this&#125;)());&quot;&gt; Show inner this&lt;/button&gt;// 等同于alert((function()&#123;return this&#125;)()); // windowalert((function()&#123;&apos;use strict&apos;; return this&#125;)()); // undefined]]></content>
      <tags>
        <tag>原始类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程师必须懂得概念（一）]]></title>
    <url>%2F2018%2F12%2F20%2Fjs-call-stack%2F</url>
    <content type="text"><![CDATA[调用堆栈 调用栈是解析器的一种机制，可以在脚本调用多个函数时，跟踪每个函数在完成执行时应该返回控制的点。（如什么函数在执行，什么函数被这个函数调用，下一个调用的函数是谁。） 当脚本要执行一个函数时，解析器把该函数添加到栈中并执行 任何被这个函数调用的函数会进一步添加到调用栈中，并且会运行到他们被上个程序调用的位置 当函数运行结束后，解释器将他从调用栈中取出，并在主代码列表中继续执行代码 如果栈调用的空间比分配给它的内存空间大，则会导致”栈溢出”]]></content>
      <tags>
        <tag>call stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的事件注册机制]]></title>
    <url>%2F2018%2F12%2F20%2Fbrowser-event%2F</url>
    <content type="text"><![CDATA[记录学习浏览器的事件注册机制 事件触发的三个阶段 window向事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处触发注册的事件 从事件触发处向window传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 1234567// 以下会先打印冒泡然后是捕获node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;冒泡&apos;)&#125;,false);node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; console.log(&apos;捕获 &apos;)&#125;,true) 那么我们怎么区分注册的事件是冒泡事件还是捕获事件？ 我们通常使用addEventListener注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture，布尔值，和 useCapture 作用一样 once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 12345678node.addEventListener(&apos;click&apos;,(event) =&gt;&#123; event.stopImmediatePropagation() console.log(&apos;冒泡&apos;)&#125;,false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener(&apos;click&apos;,(event) =&gt; &#123; console.log(&apos;捕获 &apos;)&#125;,true) stopPropagation只能阻止事件的进一步传播，默认注册的事件还是会执行。和他相反的是preventDefault方法，用于阻止默认事件的执行，但是会发送事件的进一步传播，通常是对注册事件重新定义时使用。return false;就等于同时调用了event.stopPropagation()和event.preventDefault()，即会阻止事件冒泡也会阻止默认事件。]]></content>
      <tags>
        <tag>browser event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F12%2F18%2Fjs-bibao%2F</url>
    <content type="text"><![CDATA[闭包 函数A返回了函数B,并且函数B使用了函数A的变量，函数B就成为闭包。 1234567function A()&#123; let a = 1; function B()&#123; console.log(a); &#125; return B();&#125; 为什么函数A已经调用出栈了，为什么函数B还能引用到函数A中的变量。是否和我有相同的疑问？因为函数A中的变量这时候是存储在堆上的，现在的js引擎可以通过逃逸分析辨别出那些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题：]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise实现]]></title>
    <url>%2F2018%2F12%2F17%2Fjs-promise%2F</url>
    <content type="text"><![CDATA[promise是ES6新增的语法，解决了回调地狱的问题。 可以吧Promise看成一个状态机。初始是 pending(挂起) 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// 三种状态const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;// promise 接收一个函数参数，该函数会立即执行function MyPromise(fn) &#123; let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) &#123; if (value instanceof MyPromise) &#123; // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) &#125; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125;; _this.reject = function (reason) &#123; setTimeout(() =&gt; &#123; // 异步执行，保证执行顺序 if (_this.currentState === PENDING) &#123; _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb =&gt; cb()); &#125; &#125;) &#125; // 用于解决以下问题 // new Promise(() =&gt; throw Error(&apos;error)) try &#123; fn(_this.resolve, _this.reject); &#125; catch (e) &#123; _this.reject(e); &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123; var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) =&gt; console.log(value)) onResolved = typeof onResolved === &apos;function&apos; ? onResolved : v =&gt; v; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : r =&gt; throw r; if (self.currentState === RESOLVED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () &#123; try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === REJECTED) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; // 异步执行onRejected try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (reason) &#123; reject(reason); &#125; &#125;); &#125;)); &#125; if (self.currentState === PENDING) &#123; return (promise2 = new MyPromise(function (resolve, reject) &#123; self.resolvedCallbacks.push(function () &#123; // 考虑到可能会有报错，所以使用 try/catch 包裹 try &#123; var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); self.rejectedCallbacks.push(function () &#123; try &#123; var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); &#125; catch (r) &#123; reject(r); &#125; &#125;); &#125;)); &#125;&#125;;// 规范 2.3function resolutionProcedure(promise2, x, resolve, reject) &#123; // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) &#123; return reject(new TypeError(&quot;Error&quot;)); &#125; // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) &#123; if (x.currentState === PENDING) &#123; x.then(function (value) &#123; // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); &#125;, reject); &#125; else &#123; x.then(resolve, reject); &#125; return; &#125; // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; // 规范 2.3.3.2，如果不能取出 then，就 reject try &#123; // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === &quot;function&quot;) &#123; // 规范 2.3.3.3 then.call( x, y =&gt; &#123; if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); &#125;, e =&gt; &#123; if (called) return; called = true; reject(e); &#125; ); &#125; else &#123; // 规范 2.3.3.4 resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 规范 2.3.4，x 为基本类型 resolve(x); &#125;&#125;]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用栈实现队列]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-quene%2F</url>
    <content type="text"><![CDATA[先上代码 1234567891011121314151617181920212223function Quene() &#123; var stack1 = [], stack2 = [] this.push = function(node) &#123; stack1.push(node) &#125; this.pop = function() &#123; if (stack2.length == 0) &#123; if (stack1.length == 0) &#123; return null &#125; else &#123; var len = stack1.length for (var i = 0; i &lt; len; i++) &#123; stack2.push(stack1.pop()) &#125; return stack2.pop() &#125; &#125; else &#123; return stack2.pop() &#125; &#125;&#125; 栈有入栈和出栈，实现队列就是将两个栈，通过栈顶和另一个的栈底相连，然后一个栈一直执行入栈，另一个一直执行出栈就可以了。]]></content>
      <tags>
        <tag>quene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js实现单例模式]]></title>
    <url>%2F2018%2F12%2F14%2Fjs-single%2F</url>
    <content type="text"><![CDATA[先上代码：惰性单例的精髓！！！ 1234567//单例模式抽象，分离创建对象的函数和判断对象是否已经创建var getSingle = function(fn)&#123; var result; return function()&#123; return result || (result = fn.apply(this, arguments)); &#125;&#125; 形参fn是我们的构造函数，我们只要传入任何自己需要的构造函数，就能生成一个新的惰性单例。比如说传入创建一个女朋友的构造函数，并且调用getSingle(),就能生成一个新的女朋友。如果以后再调getSingle(),也只会返回刚才创建的那个女朋友。至于新女朋友——不存在的。]]></content>
      <tags>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[Document .triangle{ height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } .box{ width: 0px; height: 0px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[用css画三角形]]></title>
    <url>%2F2018%2F12%2F11%2Fcss-triangle%2F</url>
    <content type="text"><![CDATA[1234567.triangle&#123; height:0; width:0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red;&#125; 画出的是一个倒立的三角形, 改为border-bottom就是一个正立的三角形。其中是底边为100px,高度为100px的等腰三角形。 border画多边形的原理123456789.box&#123; width: 100px; height: 100px; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125; 盒子模型 如上图的盒子模型，可以明显的看出，border实际上是一个等腰梯形。 当宽度为0时 宽度为0 四个边框变成四个等腰三角形。 TODO：继续深入了解，解决梯形的问题 当width和height为0时，默认是四个三角形，当宽度或高度不为0的时候，就可以画出梯形。 123456789.box&#123; width: 100px; height: 0; margin:10px; border-left:100px solid red; border-right:100px solid blue; border-top:100px solid yellow; border-bottom:100px solid green;&#125;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中一般怎么实现继承]]></title>
    <url>%2F2018%2F12%2F10%2Fjs-super%2F</url>
    <content type="text"><![CDATA[学习一下js的继承实现。 123456789101112131415161718192021222324function Animal(name)&#123; // 属性 this.name = name || &apos;Animal&apos;; // 实例方法 this.sleep = function()&#123; console.log(this.name + &quot; 正在睡觉。&quot;); &#125;&#125; // 原型方法 Animal.prototype.eat = function(food)&#123; console.log(this.name + &quot; 正在吃 &quot;+food);&#125;// 子类function Tiger()&#123;&#125;Tiger.prototype = new Animal();Tiger.prototype.name = &quot;Tiger&quot;;var tiger = new Tiger();console.log(tiger.name);console.log(tiger.eat(&apos;sleep&apos;));console.log(tiger.sleep());console.log(tiger instanceof Animal); //true console.log(tiger instanceof Tiger); //true 效果 ##特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 ##缺点： 可以在子类构造函数中，为子类实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参 TODO：写这个的时候还是有点蒙。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery中$的实现方式]]></title>
    <url>%2F2018%2F12%2F10%2Fjquery%2F</url>
    <content type="text"><![CDATA[实现方式(网上找的)123456789101112131415161718192021&lt;script&gt; (function(w)&#123; //工厂 function jQuery(selector, context)&#123; return new jQuery.fn.init(selector, context); &#125; //给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; &#125;; //init才是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector, context)&#123; // 构造函数 &#125;; //把构造函数的原型，替换为jQuery工厂的原型 //这么做的目的是为了实现jQuery的插件机制，让外界可以通过jQuery方便的进行扩展 init.prototype = jQuery.fn; w.jQuery = w.$ = jQuery; &#125;(window));&lt;/script&gt; 原链接 1234(function(w)&#123; // dosomthing w.jQuery = w.$ = jQuery; &#125;)(window) 目的：通过全局对象window可以调用对象jQuery或者$ 然后我们声明一个对象jQuery1234(function(w)&#123; function jQuery(selector, context)&#123;&#125; w.jQuery = w.$ = jQuery;&#125;)(window) 效果: 大功告成！但是jQuery显然是更深一层次的做法。示例方式是将原型转换为简化方法fn。然后在jQuery原型上添加一个init方法。 工厂模式什么是工厂模式？怎么在javascript使用？ 工厂模式是用来创建对象的一种最常见的设计模式。我们不暴露创建对象的具体逻辑，而是将逻辑封装到一个函数中，如示例中的jQuery函数，那么这个函数就可以被视为一个工厂。 工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。 工厂模式]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapp登录注册时的密码处理思考]]></title>
    <url>%2F2018%2F12%2F07%2Fwebsign%2F</url>
    <content type="text"><![CDATA[webapp在登录的时候怎么控制登录的安全性？ 目前通过https都可以解决这个问题。使用https自动加密传输的数据，从而解决传输密码明文的问题。然后在存储到数据库前通过md5或者其他加密算法进行加密。 #加盐 不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。通常需要对密码加盐，然后进行几次不同加密算法的加密。12// 加盐也就是给原密码添加字符串，增加原密码长度sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 摘自：interviewmap 不采用http的才使用前端加密后端解密的方式。 题外话：不加https的网站我不用，没有安全锁标志的不用!!! ╭(╯^╰)╮]]></content>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[virtualbox-centos7.5-wdcp]]></title>
    <url>%2F2018%2F12%2F04%2Fvirtual-cenos7-5%2F</url>
    <content type="text"><![CDATA[用于记录一次成功使用virtualbox虚拟机安装centos7.5成功联网并安装上wdcp 虚拟机软件当然选免费的了，而且发现好多VMware Workstation的软件链接提示有病毒，qnmlgb老子不用。 centos下载centos7.5-dvd版 要点要点1:虚拟机网卡设置要点2:虚拟机打开网络注：centos默认不启动网卡，需要手动启动路径：123cd /etc/sysconfig/network-scripts/vi ifcfg-xx 找到开头为ifcfg-的，默认是en0输入i进入编辑模式编辑该文件设置ONBOOT=yes:wq 保存退出重启网络1service network restart 有时候要重启虚拟机才能生效。]]></content>
      <categories>
        <category>virtualbox</category>
      </categories>
      <tags>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的基本使用]]></title>
    <url>%2F2018%2F11%2F29%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[记录markdown的使用方法 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字。 示例:123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体* 加粗**[要加粗的文字]**用两个*号包起来 斜体*[要斜体的文字]*用一个*号包起来_[要斜体的文字]_用一个_号包起来 斜体加粗***[要斜体加粗的文字]***用三个号包起来**_[要斜体加粗的文字]_**用三个号包起来 删除线~~[要删除线的文字]~~用两个~号包起来 示例：123456**这是加粗的文字***这是倾斜的文字*_这是倾斜的文字_***这是斜体加粗的文字*****_这是斜体加粗的文字_**~~这是加删除线的文字~~ 效果如下：这是加粗的文字这是倾斜的文字这是倾斜的文字这是斜体加粗的文字这是斜体加粗的文字这是加删除线的文字 注:加粗hexo不能用 捂脸 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例：123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下: 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 _。行内不能有其他东西，也可在号中间插入空格。 示例:1234-------******** 效果如下： 注：效果一样 o(￣︶￣)o，hexo 三个-没用 ￣□￣｜｜ 图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：1![小猪佩奇](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1543491437191&amp;di=d1111fbe37d3bd83c8121132d6117c4f&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.biaobaiju.com%2Fuploads%2F20180802%2F01%2F1533145434-yGPirmnoVd.jpg &apos;&apos;小猪&apos;&apos;) 效果如下： 超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：1[百度](https://baidu.com &quot;@百度&quot;) 百度 注：Markdown本身语法不支持链接在新页面中打开,如果想要在新页面中打开的话可以用html语言的a标签代替。1&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt; 列表无序列表使用* - + 作为列表标记注:标记和内容之间要加空格 示例:1234567891011* red* green* yellow- red- green- yellow+ red+ green+ yellow 效果如下: red green yellow red green yellow red green yellow 有序列表使用数字接着一个英文句号注:标记和内容之间要加空格 示例：1233. red2. green1. yellow red green yellow 注:有序的起始数只和第一个有关 表格语法：123456表头|表头|表头|表头---|:--:|---:|:--内容|居中|居右|居左内容|居中|居右|居左-有一个就行 效果如下：表头|表头|表头|表头—|:–:|—:|:–内容|居中|居右|居左内容|居中|居右|居左 注：很显然 hexo并没有用 下划线语法：1&lt;u&gt;123&lt;/u&gt; 效果如下：123注：使用的是html标签 颜色、字体、字体大小语法：12345678910111213&lt;font color=#ee0000 size=9 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=8 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=7 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=6 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=5 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=4 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font color=#ee0000 size=3 face=&quot;黑体&quot;&gt;我是黑体&lt;/font&gt;&lt;font color=#00ee00 size=2 face=&quot;宋体&quot;&gt;我是宋体&lt;/font&gt;&lt;font color=#ee00ee size=1 face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;color 16进制颜色size 6-1分别对应h1-h6共6个级别face 字体 效果如下： 我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑我是黑体我是宋体我是微软雅黑 代码语法：1234567单行代码`代码内容`多行代码块(```) 代码块(```) 效果如下 单行代码代码内容 多行代码块1代码块 流程图示例：123456789flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果如下flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 注：hexo 不支持]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
